---
tags:
- 折叠方案
- 同态承诺
- 增量可验证计算
- 递归零知识证明
- Plonk算术化

title: Sangria
date: 2023-03-07 00:00:00
#published: false
sidebar:
    nav: cryptoland
---

> - 原文：[Sangria: a Folding Scheme for PLONK
](https://geometry.xyz/notebook/sangria-a-folding-scheme-for-plonk)
> - 作者：Nicolas Mohnblatt
> - 译者：Kurt Pan

{: .info}
如 Nova [^KST22] 所示，可以使用折叠方案和 zkSNARK 实现增量可验证计算 (IVC)。 
在本文中，我们提出了对PLONK算术化 [^GWC19] 变体的折叠方案。 
之后，我们扩展松弛PLONK 算术化，以接受2次自定义门和具有更高门扇入扇出数的电路。 最后，概述了未来工作的路径，包括折叠更高次的门、支持查找门和为松弛PLONK算术化设计 IOP。

> 本文是 [Sangria 技术论文](https://github.com/geometryresearch/technical_notes/blob/main/sangria_folding_plonk.pdf)的浓缩版。 请参阅完整版以获取证明和扩展讨论。 我们假设读者熟悉 IVC 和 Nova。 建议初步查看和阅读：[Justin Drake 的 ZK Whiteboard Session](https://youtu.be/SwonTtOQzAk) 和这篇 [Lambdaclass 博客文章](https://cryptography.land/2023/03/05/nova)。

<!--more-->

## 预备知识
### PLONK算术化
在 PLONK 中，计算被表示为一个矩阵 $\mathbf{M}$，具有三列 $\mathbf{a}、\mathbf{b}、\mathbf{c}$ 和 $n+s+1$ 行。 $n$ 是公共输入的数量，$s$ 是门的数量，额外的一行检查最终结果是否为 1（即电路是否满足）。

![iWkbtE.png](https://i.328888.xyz/2023/03/28/iWkbtE.png)

第 $i$ 行的值 -- $\mathbf{a}_i, \mathbf{b}_i, \mathbf{c}_i$ -- 
分别对应第 $i$ 个门的左输入、右输入和输出。
第$i$个门定义为：$$\left(\mathbf{q}_{\mathbf{L}}\right)_i,\left(\mathbf{q}_{\mathbf{R}}\right)_i,\left(\mathbf{q}_{\mathbf{O}}\right)_i,\left(\mathbf{q}_{\mathbf{M}}\right)_i,\left(\mathbf{q}_{\mathbf{C}}\right)_i$$ 是每个选择子向量的第$i$个值。  
$$
\mathcal{Q}=\left\{\mathbf{q}_{\mathbf{L}}, \mathbf{q}_{\mathbf{R}}, \mathbf{q}_{\mathbf{o}}, \mathbf{q}_{\mathbf{M}}, \mathbf{q}_{\mathbf{C}}\right\}
$$为选择子向量集合。

门使用复制约束“连接”在一起，例如 $\mathbf{a}_3=\mathbf{c}_1$ - 门 3 的左侧输入是门 1 的输出。$\mathcal{S} $为复制约束集合。

电路完全由元组 $(\mathcal{Q}, \mathcal{S})$ 定义。

### 折叠方案
Nova论文引入了折叠方案并给出了如下直观定义：

{: .warning}
[...] 一个对于关系$\mathcal{R}$的折叠方案，是一个协议：将检验两个$\mathcal{R}$ 中实例的任务归约到检验单个$\mathcal{R}$中实例的任务。

完整定义见论文中的定义6。
### 承诺方案
方案使用对有限域 $\mathbb{F}$ 中的元素向量的隐藏和绑定的加法同态承诺方案。 我们将这样的方案记为为 $\operatorname{Com}$ 。 $\bar{A}=\operatorname{Com}\left(\mathrm{pp}_C, \mathbf{a} ; r\right)$ 为对向量 $\mathbf{a}$  使用随机值 $r \in \mathbb{F}$ 和承诺参数 $\mathrm{pp}_C$的承诺。

## Sangria
Nova 为 R1CS 算术化构造了一个折叠方案。 这里，我们提出了对PLONK 算术化的折叠方案。 使用与 Nova 相同的洞见：
- 折叠是通过对输入的实例-见证对进行**随机线性组合**来进行的。
- 交叉项被吸收到**错误**（或松弛）向量和**缩放因子**之中。
- 通过对见证和松弛向量的**加法同态承诺**，方案变得不再平凡。

### 松弛PLONK门方程

对于标量 $u \in \mathbb{F}$ 和错误（松弛）向量 $\mathbf{e} \in \mathbb{F}^{n+s+1}$ ，松弛PLONK 门方程定义为 :

$$
C_{\mathcal{Q}, i}^{\prime}(\mathbf{a}, \mathbf{b}, \mathbf{c}, u, \mathbf{e}):=u\left[\left(\mathbf{q}_{\mathbf{L}}\right)_i \mathbf{a}_i+\left(\mathbf{q}_{\mathbf{R}}\right)_i \mathbf{b}_i+\left(\mathbf{q}_{\mathbf{O}}\right)_i \mathbf{c}_i\right]+\left(\mathbf{q}_{\mathbf{M}}\right)_i \mathbf{a}_i \mathbf{b}_i+u^2\left(\mathbf{q}_{\mathbf{C}}\right)_i+\mathbf{e}_i
$$

松弛PLONK 中的复制约束与 PLONK 复制约束相同。 松弛 PLONK 的迹由元组 $(\mathbf{a}, \mathbf{b}, \mathbf{c}, u, \mathbf{e})$ 表示。

对于 PLONK 实例-见证对 $(\mathbf{X}, \mathbf{W})$，我们将松弛PLONK实例-见证对 $(U, W)$ 定义为：

$$
U:=\left(\mathbf{X}, u, \overline{W_a}, \overline{W_b}, \overline{W_c}, \bar{E}\right)
$$

$$
W:=\left(\mathbf{W}, \mathbf{e}, r_a, r_b, r_c, r_e\right)
$$



其中 $$\overline{W_a}=\operatorname{Com}\left(\mathrm{pp}_W, \mathbf{w}_{\mathbf{a}} ; r_a\right), \overline{W_b}=\operatorname{Com}\left(\mathrm{pp}_W, \mathbf{w}_{\mathbf{b}} ; r_b\right),\overline{W_c}=\operatorname{Com}\left(\mathrm{pp}_W, \mathbf{w}_{\mathbf{c}} ; r_c\right)$$ 
且 $$\bar{E}=\operatorname{Com}\left(\mathrm{pp}_E, \mathbf{e} ; r_e\right)$$。

重要的是，任何松弛PLONK 关系都可以通过以下方式转换为PLONK 关系：设置 $u=1$, $\mathbf{e}=\overrightarrow{0}$ 并提供必要的承诺。 因此，松弛PLONK 算术化是 NP 完全的。
### 对松弛PLONK的折叠方案

按照 Nova 的符号，折叠方案由 4 种算法 $\mathcal{G}, \mathcal{K}, \mathcal{P}, \mathcal{V}$ 定义：
- $\mathcal{G}\left(1^\lambda\right) \rightarrow \mathrm{pp}$：输出大小边界 $n, s \in \mathbb{N}$ 和承诺参数 $\mathrm{pp}_W$ 和 $\mathrm{pp}_E$ ，分别用于大小为 $s$ 和 $n+s+1$ 的向量。
- $\mathcal{K}(\mathrm{pp},(\mathcal{Q}, \mathcal{S})) \rightarrow(\mathrm{pk}, \mathrm{vk}):$ 输出 $\mathrm{vk} \leftarrow \perp$ 且 $\mathrm{pk} \leftarrow(\mathrm{pp}, \mathrm{vk},(\mathcal{Q}, \mathcal{S}))$。

验证者 $\mathcal{V}$ 输入验证者密钥 $\mathrm{vk}$ 和两个承诺的松散PLONK 实例， $\left(\mathbf{X}^{\prime}, u^{\prime}, \overline{W_a ^{\prime}}, \overline{W_b^{\prime}}, \overline{W_c^{\prime}}, \overline{E^{\prime}}\right)$ 和 $\left(\mathbf {X}^{\prime \prime}, u^{\prime \prime}, \overline{W_a^{\prime \prime}}, \overline{W_b^{\prime \prime}}, \overline{W_c ^{\prime \prime}}, \overline{E^{\prime \prime}}\right)$。 证明者 $\mathcal{P}$ 输入证明者密钥 $\mathrm{pk}$ 和两个实例及其相应的见证 $\left(\mathbf{W}^{\prime}, \mathbf{e}^{\prime}, r_a^{\prime}, r_b^{\prime}, r_c^{\prime}, r_e^{\prime}\right)$ and $\left(\mathbf{W}^{\prime \prime}, \mathbf{e}^{\prime \prime}, r_a^{\prime \prime}, r_b^{\prime \prime}, r_c^{\prime \prime}, r_e^{\prime \prime}\right)$。

Sangria 折叠方案按如下方式进行：

1. $\mathcal{P}$ 随机采样 $r_t$ ， 发送 $\bar{T}=\operatorname{Com}\left(\mathrm{pp}_E, \mathbf{t} ; r_t\right)$ ，其中$\mathbf{t}$ 按如下计算：

$$
\begin{aligned}
\mathbf{t}:= & u^{\prime \prime}\left(\mathbf{q}_{\mathbf{L}} \circ \mathbf{a}^{\prime}+\mathbf{q}_{\mathbf{R}} \circ \mathbf{b}^{\prime}+\mathbf{q}_{\mathbf{O}} \circ \mathbf{c}^{\prime}\right)+u^{\prime}\left(\mathbf{q}_{\mathbf{L}} \circ \mathbf{a}^{\prime \prime}+\mathbf{q}_{\mathbf{R}} \circ \mathbf{b}^{\prime \prime}+\mathbf{q}_{\mathbf{O}} \circ \mathbf{c}^{\prime \prime}\right) \\
& +\mathbf{q}_{\mathbf{M}} \circ\left(\mathbf{a}^{\prime} \circ \mathbf{b}^{\prime \prime}+\mathbf{a}^{\prime \prime} \circ \mathbf{b}^{\prime}\right) \\
& +2 r u^{\prime} u^{\prime \prime} \mathbf{q}_{\mathbf{C}}
\end{aligned}
$$

其中$o$ 指代逐元素乘法。

2. $\mathcal{V}$ 随机采样挑战$r$。

3. $\mathcal{P}$ 和 $\mathcal{V}$ 输出折叠实例 $\left(\mathbf{X}, u, \overline{W_a}, \overline{W_b}, \overline{W_c}, \bar{E}\right)$ ，其中：

$$
\begin{aligned}
\mathbf{X} & \leftarrow \mathbf{X}^{\prime}+r \mathbf{X}^{\prime \prime} \\
u & \leftarrow u^{\prime}+r u^{\prime \prime} \\
\overline{W_a} & \leftarrow \overline{W_a^{\prime}}+r \overline{W_a^{\prime \prime}} \\
\overline{W_b} & \leftarrow \overline{W_b^{\prime}}+r \overline{W_b^{\prime \prime}} \\
\overline{W_c} & \leftarrow \overline{W_c^{\prime}}+r \overline{W_c^{\prime \prime}} \\
\bar{E} & \leftarrow \overline{E^{\prime}}-r \bar{T}+r^2 \overline{E^{\prime \prime}}
\end{aligned}
$$

4. $\mathcal{P}$ 输出折叠见证 $\left(\mathbf{W}, \mathbf{e}, r_a, r_b, r_c, r_e\right)$ ，其中：

$$
\begin{aligned}
\mathbf{W} & \leftarrow \mathbf{W}^{\prime}+r \mathbf{W}^{\prime \prime} \\
r_a & \leftarrow r_a^{\prime}+r \cdot r_a^{\prime \prime} \\
r_b & \leftarrow r_b^{\prime}+r \cdot r_b^{\prime \prime} \\
r_c & \leftarrow r_c^{\prime}+r \cdot r_c^{\prime \prime} \\
\mathbf{e} & \leftarrow \mathbf{e}^{\prime}-r \mathbf{t}+r^2 \mathbf{e}^{\prime \prime} \\
r_e & \leftarrow r_e^{\prime}-r \cdot r_t+r^2 \cdot r_e^{\prime \prime}
\end{aligned}
$$

{: .warning}
定理：上述构造是对承诺松弛PLONK算术化的公开抛币折叠方案，具有完美完备性、知识可靠性、零知识性。

证明直观。 完美完备性可以按照代数规则展开直到下式成立：

$$
C_{\mathcal{Q}, i}^{\prime}(\mathbf{a}, \mathbf{b}, \mathbf{c}, u, \mathbf{e})=C_{\mathcal{Q}, i}^{\prime}\left(\mathbf{a}^{\prime}, \mathbf{b}^{\prime}, \mathbf{c}^{\prime}, u^{\prime}, \mathbf{e}^{\prime}\right)+r^2 C_{\mathcal{Q}, i}^{\prime}\left(\mathbf{a}^{\prime \prime}, \mathbf{b}^{\prime \prime}, \mathbf{c}^{\prime \prime}, u^{\prime \prime}, \mathbf{e}^{\prime \prime}\right)
$$
也可以容易看到复制约束也保持成立。

使用与 [^KST22] 相同的策略来证明知识可靠性。 具体来说，我们将分叉引理应用于折叠方案（[^KST22] 中的引理 1）以获得三个脚本。 然后我们证明提取器使用所有三个脚本来插值出原始的 $\mathbf{e}^{\prime}, r_e^{\prime}$ 和 $\mathbf{e}^{\prime \prime}, r_e^ {\prime \prime}$ 的值，以及任何两个脚本以插值出 $\left(\mathbf{W}^{\prime}, r_a^{\prime}, r_b^{\prime}, r_c^{\prime}\right)$ 和 $\left(\mathbf{W}^{\prime \prime}, r_a^{\prime \prime}, r_b^{\prime \prime}, r_c^{\prime \prime}\right)$。 接着证明插值结果属于满足电路的每个门等式和复制约束的迹。

最后，零知识成立，因为证明者的消息是隐藏的承诺，而验证者只发送一个公共随机值。 完整的[技术说明](https://github.com/geometryresearch/technical_notes/blob/main/sangria_folding_plonk.pdf)中给出了证明。
### Degree 2 Custom Gates
2次自定义门及其选择子记为：

$$
G_i(\mathbf{a}, \mathbf{b}, \mathbf{c}):=\left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g\left(\mathbf{a}_i, \mathbf{b}_i, \mathbf{c}_i\right)
$$

要折叠这样的门，将 $g$ 写为单项式的和，然后将单项式按次数分开。 令 $g_C、g_1$ 和 $g_2$ 分别为常数、1 次和 2 次单项式的和。 可以将松弛约束方程写为：

$$
\begin{aligned}
C_{\mathcal{Q}, i}^{\prime}(\mathbf{a}, \mathbf{b}, \mathbf{c}, u, \mathbf{e}):= & u\left[\left(\mathbf{q}_{\mathbf{L}}\right)_i \mathbf{a}_i+\left(\mathbf{q}_{\mathbf{R}}\right)_i \mathbf{b}_i+(\mathbf{q} _\mathbf{O})_i \mathbf{c}_i+\left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g_1\left(\mathbf{a}_i, \mathbf{b}_i, \mathbf{c}_i\right)\right] \\
& +\left(\mathbf{q}_{\mathbf{M}}\right)_i \mathbf{a}_i \mathbf{b}_i+\left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g_2\left(\mathbf{a}_i, \mathbf{b}_i, \mathbf{c}_i\right)+u^2\left(\mathbf{q}_{\mathbf{C}}\right)_i+u^2\left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g_C+\mathbf{e}_i
\end{aligned}
$$

折叠 $\left(\mathbf{a}^{\prime}, \mathbf{b}^{\prime}, \mathbf{c}^{\prime}, u^{\prime}, \mathbf{e} ^{\prime}\right)$ 和 $\left(\mathbf{a}^{\prime \prime}, \mathbf{b}^{\prime \prime}, \mathbf{c}^{\prime \prime}, u^{\prime \prime}, \mathbf{e}^{\prime \prime}\right)$ 仍然通过随机线性组合来进行，但是必须调整 $\mathbf{t}$ 向量以吸收由以下每个2次表达式产生的交叉项：

$$
\begin{aligned} 
& \left(u^{\prime}+r u^{\prime \prime}\right)\left[\left(\mathbf{q}_{\mathbf{L}}\right)_i\left(\mathbf{a}_i^{\prime}+r \mathbf{a}^{\prime \prime}{ }_i\right)+\left(\mathbf{q}_{\mathbf{R}}\right)_i\left(\mathbf{b}^{\prime}{ }_i+r \mathbf{b}^{\prime \prime}{ }_i\right)+\left(\mathbf{q}_{\mathbf{o}}\right)_i\left(\mathbf{c}_i^{\prime}+r \mathbf{c}^{\prime \prime}{ }_i\right)+\left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g_1\left(\left(\mathbf{a}_i^{\prime}+r \mathbf{a}^{\prime \prime}{ }_i\right),\left(\mathbf{b}^{\prime}{ }_i+r \mathbf{b}^{\prime \prime}{ }_i\right)\right.\right. \left.\left.,\left(\mathbf{c}_i^{\prime}+r \mathbf{c}_i^{\prime \prime}\right)\right)\right]\\ & \left(\mathbf{q}_{\mathbf{M}}\right)_i\left(\mathbf{a}_i^{\prime}+r \mathbf{a}_i^{\prime \prime}\right)\left(\mathbf{b}_i^{\prime}+r \mathbf{b}_i^{\prime \prime}\right) \\ & \left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g_2\left(\left(\mathbf{a}_i^{\prime}+r \mathbf{a}_i^{\prime \prime}\right),\left(\mathbf{b}_i^{\prime}+r \mathbf{b}_i^{\prime \prime}\right),\left(\mathbf{c}_i^{\prime}+r \mathbf{c}_i^{\prime \prime}{ }_i\right)\right) \\ & \left(u^{\prime}+r u^{\prime \prime}\right)^2\left(\mathbf{q}_{\mathbf{C}}\right)_i \\ & \left(u^{\prime}+r u^{\prime \prime}\right)^2\left(\mathbf{q}_{\mathbf{G}}\right)_i \cdot g_C
\end{aligned}
$$

### 更高的扇入和扇出
只要门方程的次数小于等于 2，当前方案就可以支持更高扇入扇出数量的电路。每个额外的门输入或输出都需要一个额外的见证列承诺。

## 未来工作
本文为标准 PLONK 算术化构造了折叠方案，并介绍了一些自定义的功能。 最后简要指出即将到来的未来工作的方向。

### 使用对Sangria的zkSNARK的简洁 IVC
Nova 表明一个折叠方案直接蕴含 IVC。 然而，这些 IVC 证明既不简洁也不是零知识的。 为了实现这两个性质，必须为新的松弛算术化设计一个 zKSNARK。 一个可能的方向是将 Sangria 迹转换为 PLONKish 迹，并为松弛向量添加一个额外的见证列。 另一个方向是直接修改 IOP 以管理新引入的 $u$ 和 $\mathbf{e}$ 值。

### 降低递归开销
在当前构造中，折叠验证者每个见证列使用1个承诺。 该方案还可以通过将见证矩阵 $\mathbf{W}$ 拍平为单个列向量，从而允许验证者使用单个见证承诺（和在Nova中一样）。 
这样做需要参考串 $\mathrm{pp}_W$ 相对具有“扇入 2，扇出 1”门的电路来说要长三倍。 考虑到标准 PLONK IOP 使用对每个见证列的承诺，它还可能在完整的 IVC 方案中引入额外的检查和承诺打开。

### 更高次自定义门
“随机线性组合”折叠策略可以实现更高次的自定义门。 设$d$为约束方程的**最高**次数，整体策略如下：
1. 将非松弛约束方程 $C_{\mathcal{Q}, i}$ 表示为单项式之和。
2. 使用松弛因子 $u$ 的幂使 $C_{\mathcal{Q}, i}$ 成为**齐次** $d$次多项式。
3. 加入错误项$\mathbf{e}$吸收交叉项。 交叉项现在具有$r$ 的从 1 到 $d-1$ 次幂。 将它们分别收集到向量 $$\mathbf{t}_1, \mathbf{t}_2, \ldots, \mathbf{t}_{\mathbf{d}-1}$$ 使得

$$
\mathbf{e}=\mathbf{e}^{\prime}-\sum_{k=1}^{d-1} r^k \mathbf{t}_{\mathbf{k}}+r^d \mathbf{e}^{\prime \prime}
$$

4. 按照标准结构中的描述进行折叠，进行以下修改：
- 证明者计算并发送**每个** $\mathbf{t}_{\mathbf{k}}$ 向量的承诺。
- 按照上面等式中的定义计算 $\mathbf{e}$ 并在承诺空间中应用相应的操作。

**开销**。 该策略为验证者和证明者都引入了额外的工作。 为了计算 $d-1$个交叉项向量及其承诺，证明者将执行 $\mathcal{O}(d *(n+s))$ 次域运算和 $\mathcal{O}(d *(n +s))$ 次点加。 类似地，在承诺空间中验证者计算 $\mathcal{O}(d)$ 次点加。 注意验证者的工作依然是安全参数和电路规模方面的常数。 然而确实需要在实现 IVC的折叠和拆分累积 [^BCLMS20] 方法之间去进行更仔细的比较。

**3次**。使用上述策略对3次门使用随机线性组合策略的一个提案如下：

$$
u^2\left[\left(\mathbf{q}_{\mathbf{L}}\right)_i \mathbf{a}_i+\left(\mathbf{q}_{\mathbf{R}}\right)_i \mathbf{b}_i+\left(\mathbf{q}_{\mathbf{O}}\right)_i \mathbf{c}_i\right]+u\left(\mathbf{q}_{\mathbf{M}}\right)_i \mathbf{a}_i \mathbf{b}_i+\left(\mathbf{q}_{\mathbf{3}}\right)_i \mathbf{a}_i \mathbf{b}_i \mathbf{c}_i +u^3\left(\mathbf{q}_{\mathbf{C}}\right)_i+\mathbf{e}_i
$$


其中错误项被适当调整过以吸收交叉项（有关交叉项的显式表示，请参阅[完整版](https://github.com/geometryresearch/technical_notes/blob/main/sangria_folding_plonk.pdf)）。

### 查找门
PLONKish 算术化与 R1CS 的区别部分在于它们集成了查找论证的能力。 我们对通过为支持查找的算术化开发折叠策略来保持这种灵活性很感兴趣。

## 致谢
感谢 Nat Bunner 和 Lev Soukhanov 对高次门折叠策略的改进。 我们还要感谢 Andrija Novakovic、Lai Ying Tong、Kobi Gurkan 和 Koh Wei Jie 提供的有益投入和贡献。

{% include refs.md %}



