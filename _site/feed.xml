<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2023-02-24T15:39:46+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">密码之地 Cryptoland</title><subtitle>开放互联网上密码学中文内容的应许之地 &gt;</subtitle><author><name>Kurt Pan</name></author><entry><title type="html">给人民群众的BLS12-381指南 (未完成)</title><link href="http://localhost:4000/2023/02/23/bls12381-restofus.html" rel="alternate" type="text/html" title="给人民群众的BLS12-381指南 (未完成)" /><published>2023-02-23T08:00:00+08:00</published><updated>2023-02-23T08:00:00+08:00</updated><id>http://localhost:4000/2023/02/23/bls12381-restofus</id><content type="html" xml:base="http://localhost:4000/2023/02/23/bls12381-restofus.html"><![CDATA[<blockquote>
  <ul>
    <li>原文：<a href="https://hackmd.io/@benjaminion/bls12-381">BLS12-381 For The Rest Of Us</a></li>
    <li>作者：Ben Edgington</li>
    <li>译者：Kurt Pan</li>
  </ul>
</blockquote>

<p class="info"><strong><em>开始鼓捣之前，我希望我知道的。</em></strong>
近年来，椭圆曲线<a href="https://electriccoin.co/blog/new-snark-curve/">BLS12-381</a>已成逐渐火了起来。许多协议都将其应用到了数字签名和零知识证明中：Zcash、Ethereum 2.0、Skale、Algorand、Dfinity、Chia 等等。
不幸的是，现有的关于 BLS12-381 的材料里充满着晦涩的咒语，比如“实例化其六角扭”和“最优扩展域塔”。我就是来解决这个问题的 :smile: <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>
两个名词的正确翻译和含义
我不会对椭圆曲线及其令人兴奋的群的性质进行一般性介绍。这方面已经有一些<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">很棒的入门书</a>了，我将假设读者具有这些基础知识。当然，这里有很多内容并非只特定于 BLS12-381，而是也适用于其他曲线。</p>

<!--more-->

<h2 id="动机">动机</h2>
<p>BLS12-381 是一个配对友好的椭圆曲线。</p>

<p><a href="https://en.wikipedia.org/wiki/Pairing-based_cryptography">基于配对的密码学</a>在过去几十年得到了很大发展，使很多有用的新应用成为了可能，例如<a href="https://crypto.stanford.edu/~dabo/pubs/papers/aggreg.pdf">可高效聚合的</a><a href="https://www.iacr.org/archive/asiacrypt2001/22480516.pdf">短数字签名</a>、<a href="https://en.wikipedia.org/wiki/Boneh-Franklin_scheme">基于身份的密码学</a>、<a href="http://cgi.di.uoa.gr/~aggelos/crypto/page4/assets/joux-tripartite.pdf">单轮多方密钥交换</a>和高效的多项式承诺方案（如<a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">KZG承诺</a>。</p>

<p>配对友好的椭圆曲线是具有良好的嵌入度（将在<a href="">下面</a>解释！）和大素数阶子群（也见<a href="">下文</a>）的曲线。这些曲线很少见。如果你随机创建一条椭圆曲线，它是配对友好的可能性非常之小。然而，它们是可以构造出来的， BLS 曲线就被显式构造为配对友好的。还有<a href="https://eprint.iacr.org/2006/372.pdf">其他几个</a>配对友好曲线系列。</p>

<details>
<summary><b>如果你想了解有关基于配对的密码学的更多信息，请阅读下面这些不错的材料：</b> <i>（点击展开。）</i></summary>
<p style="margin-left: .3em; border-left: .15em solid black; padding-left: .5em;">
一个简短的（但技术性的）<a href="https://courses.csail.mit.edu/6.897/spring04/L25.pdf">解释</a>，以及<a href="https://www.math.uwaterloo.ca/~ajmeneze/publications/pairings.pdf">另一个</a>。
<br /><br />
<a href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">Vitalik 对椭圆曲线配对</a>进行了很好的一般性介绍。
<br /><br />
这份<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4730686/">NIST 报告</a>可读性很强。我推荐第 2 节和附录。
<br /><br />
同样好的背景材料是配对友好曲线的<a href="https://tools.ietf.org/id/draft-yonezawa-pairing-friendly-curves-02.html">IETF 标准草案</a>。
<br /><br />
如果你想真的<em>理解</em>这些东西，那么<a href="https://www.craigcostello.com.au/s/PairingsForBeginners.pdf">Pairings for Beginners</a>就很棒。如果你仔细研究，学习里面的例子，事实证明它并没有看起来那么可怕。我真的很推荐这个（但我也一直都在学习中……）。
</p>
</details>

<h2 id="关于曲线bls12-381">关于曲线BLS12-381</h2>
<h3 id="历史">历史</h3>
<h3 id="命名">命名</h3>
<h3 id="曲线方程和参数">曲线方程和参数</h3>
<h3 id="域扩展">域扩展</h3>
<h3 id="两条曲线">两条曲线</h3>
<h3 id="子群">子群</h3>
<h3 id="扭">扭</h3>
<h3 id="配对">配对</h3>
<h3 id="嵌入度">嵌入度</h3>
<h3 id="安全级别">安全级别</h3>
<h3 id="协因子">协因子</h3>
<h3 id="单位根">单位根</h3>

<h2 id="使用曲线bls12-381">使用曲线BLS12-381</h2>
<h3 id="bls数字签名">BLS数字签名</h3>
<h4 id="公私钥">公私钥</h4>
<h4 id="签名">签名</h4>
<h4 id="验证">验证</h4>
<h4 id="聚合">聚合</h4>
<h4 id="恶意密钥攻击">恶意密钥攻击</h4>
<h3 id="交换g1和g2">交换G1和G2</h3>
<h3 id="点压缩">点压缩</h3>
<h3 id="子群成员检验">子群成员检验</h3>
<h3 id="生成元">生成元</h3>
<h3 id="最终指数">最终指数</h3>
<h3 id="哈希到曲线">哈希到曲线</h3>
<h4 id="哈希并检验">哈希并检验</h4>
<h4 id="simplified-swu-map">Simplified SWU map</h4>
<h3 id="协因子清除">协因子清除</h3>
<h3 id="扩展塔">扩展塔</h3>
<h3 id="坐标系">坐标系</h3>
<h4 id="仿射坐标">仿射坐标</h4>
<h4 id="标准射影坐标">标准射影坐标</h4>
<h4 id="jacobian-坐标">Jacobian 坐标</h4>

<h2 id="进一步阅读资源">进一步阅读资源</h2>
<p>上面链接了很多参考资料，这里就不重复了。 我只会挑出一些特别有用或有趣的东西。</p>

<p>有用的参考资料：</p>

<p>原始 BLS12-381 公告
参数和序列化的简明描述
IETF 标准草案
上面的 tl;dr 版本，BLS for Busy People
一般来说，配对库的实现往往是高度优化的和/或非常通用的（支持许多曲线），这使得它们很难学习。 Paul Miller 的 JavaScript/TypeScript 中的 Noble BLS12-381 库绝对是比较容易理解的。</p>

<p>最后，一些有趣和有趣的读物：</p>

<p>这份关于 Curve9769 的全新白皮书与 BLS12-381 没有直接关系，但它是对设计和实现椭圆曲线（在这种情况下不是配对友好的）的乐趣和痛苦的写得很好的精彩探索。
配对并没有死，只是在休息。 一个很好的概述介绍。 一些 BLS12-381 的东西。</p>

<p>就这样吧，朋友们拜拜！</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>我多年前学习过数学，但一直在努力回避任何与纯数学有关的事情，包括群论。 我现在很后悔。 无论如何，这不会太技术性，但我也不是专家，所以可能会出错，而且一般来说会有点手忙脚乱。 如果不是很明显的话我再澄清一下，我不是密码学家。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Kurt Pan</name></author><category term="双线性映射" /><category term="BLS曲线" /><category term="BLS签名" /><summary type="html"><![CDATA[原文：BLS12-381 For The Rest Of Us 作者：Ben Edgington 译者：Kurt Pan 开始鼓捣之前，我希望我知道的。 近年来，椭圆曲线BLS12-381已成逐渐火了起来。许多协议都将其应用到了数字签名和零知识证明中：Zcash、Ethereum 2.0、Skale、Algorand、Dfinity、Chia 等等。 不幸的是，现有的关于 BLS12-381 的材料里充满着晦涩的咒语，比如“实例化其六角扭”和“最优扩展域塔”。我就是来解决这个问题的 :smile: 1 两个名词的正确翻译和含义 我不会对椭圆曲线及其令人兴奋的群的性质进行一般性介绍。这方面已经有一些很棒的入门书了，我将假设读者具有这些基础知识。当然，这里有很多内容并非只特定于 BLS12-381，而是也适用于其他曲线。 我多年前学习过数学，但一直在努力回避任何与纯数学有关的事情，包括群论。 我现在很后悔。 无论如何，这不会太技术性，但我也不是专家，所以可能会出错，而且一般来说会有点手忙脚乱。 如果不是很明显的话我再澄清一下，我不是密码学家。 &#8617;]]></summary></entry><entry><title type="html">哈希到secp256k1椭圆曲线</title><link href="http://localhost:4000/2023/02/23/hashtosecp256k1.html" rel="alternate" type="text/html" title="哈希到secp256k1椭圆曲线" /><published>2023-02-23T08:00:00+08:00</published><updated>2023-02-23T08:00:00+08:00</updated><id>http://localhost:4000/2023/02/23/hashtosecp256k1</id><content type="html" xml:base="http://localhost:4000/2023/02/23/hashtosecp256k1.html"><![CDATA[<blockquote>
  <ul>
    <li>原文：<a href="https://geometry.xyz/notebook/Hashing-to-the-secp256k1-Elliptic-Curve">Hashing to the secp256k1 Elliptic Curve</a></li>
    <li>作者：<a href="https://twitter.com/weijie_eth">weijie.eth</a></li>
    <li>译者：Kurt Pan</li>
  </ul>
</blockquote>

<p class="info">许多密码学协议，比如<a href="https://www.iacr.org/cryptodb/data/paper.php?pubkey=30862">可聚合分布式密钥生成</a>和BLS签名方案，都需要用到<strong>哈希到曲线</strong>算法，确定性地将任意字节串转换成椭圆曲线上的一个点。这样的算法并非平凡，因为不仅仅是要产生有效的曲线点，而且还要以安全且高效的方式来产生。</p>

<p>这篇文章中，我将总结哈希到曲线函数的技术现状，重点是其在<code class="language-plaintext highlighter-rouge">secp256k1</code>椭圆曲线上的应用，以及一般的哈希到曲线算法背后的一些安全考虑和性能优化。</p>

<!--more-->

<h2 id="背景">背景</h2>
<p>在 <a href="https://geometry.xyz/">Geometry</a> ，我们与<a href="https://0xparc.org/">0xPARC</a> 和 <a href="https://personaelabs.org/">Personae Labs</a> 的Aayush 和 Lakshman 合作开发了一个<a href="https://eprint.iacr.org/2022/1255">产生唯一确定性nullifiers的签名方案</a>。该方案旨在与现有的以太坊钱包兼容，所以会使用到<a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1 曲线</a> 上的密钥对。为产生一个签名，签名者需要导出一个椭圆曲线点，作为对消息和公钥的哈希到曲线函数的输出。</p>

<p>为最大限度地提高这个签名方案被广泛采用和标准化的机会，我们选择了一个哈希到曲线的密码套件<a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-secp256k1_xmdsha-256_sswu_r"><code class="language-plaintext highlighter-rouge">secp256k1_XMD:SHA-256_SSWU_RO_</code></a>，它本身就是一组正在进行标准化的函数的一部分。是在提交给<a href="https://irtf.org/">互联网研究任务组（IRTF）</a> 的标准草案<a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html">哈希到椭圆曲线</a> 中定义的。注意在本文撰写时，该文档相对较新，尚未正式成为<a href="https://www.ietf.org/standards/">IETF标准</a>。</p>

<p>在未来的文章中，我将详细介绍这个哈希到曲线函数的一个<a href="https://github.com/geometryresearch/secp256k1_hash_to_curve">circom实现</a> ，这使得它可以应用于zk-SNARK电路中。</p>

<h2 id="关于哈希到椭圆曲线">关于哈希到椭圆曲线</h2>
<p><strong>哈希到椭圆曲线</strong>（以下简称标准草案）提供了将任意字节串哈希到椭圆曲线的具体算法。它为各种椭圆曲线，如<code class="language-plaintext highlighter-rouge">secp256k1</code>、<code class="language-plaintext highlighter-rouge">P-256</code>和<code class="language-plaintext highlighter-rouge">BLS12-381</code>，定义了特定的密码套件–即一系列的常数和算法。虽然它只为这有限的一组椭圆曲线提供了密码套件，但如果读者需要，它也为如何为其他曲线构建安全的密码套件提供了一般指导。</p>

<p>标准草案定义了<code class="language-plaintext highlighter-rouge">hash_to_curve</code>函数如下：</p>
<ol>
  <li>给定任意长输入消息<code class="language-plaintext highlighter-rouge">msg</code>，使用<code class="language-plaintext highlighter-rouge">hash_to_field</code>确定性地产生两个域元素<code class="language-plaintext highlighter-rouge">u[0]</code> 和 <code class="language-plaintext highlighter-rouge">u[1]</code></li>
  <li>计算<code class="language-plaintext highlighter-rouge">Q0 = map_to_curve(u[0])</code></li>
  <li>计算<code class="language-plaintext highlighter-rouge">Q1 = map_to_curve(u[1])</code></li>
  <li>使用点加计算<code class="language-plaintext highlighter-rouge">R = Q0 + Q1</code></li>
  <li>清除<code class="language-plaintext highlighter-rouge">R</code>的协因子并返回结果
    <h3 id="hash_to_field"><code class="language-plaintext highlighter-rouge">hash_to_field</code></h3>
    <p><code class="language-plaintext highlighter-rouge">hash_to_field</code> 运行 <code class="language-plaintext highlighter-rouge">expand_message_xmd</code>， 对<code class="language-plaintext highlighter-rouge">msg</code>进行哈希并输出一个96字节的数组。输出 <code class="language-plaintext highlighter-rouge">u[0]</code> 是前48字节， <code class="language-plaintext highlighter-rouge">u[1</code>] 是后48字节。对于<code class="language-plaintext highlighter-rouge">expand_message_xmd</code>我将在另外的小节中详述；现在只需简单的认为是输出了一个输入的均匀随机哈希即可。</p>
    <h3 id="map_to_curve"><code class="language-plaintext highlighter-rouge">map_to_curve</code></h3>
    <p><code class="language-plaintext highlighter-rouge">map_to_curve</code>使用一个常数时间方法，给定一个域元素，总是能找到一个椭圆曲线上的点。根据曲线的类型和参数的不同，该方法有不同的变体。</p>
  </li>
</ol>

<p>该规范草案为<strong>Montgomery曲线</strong>规定了Elligator 2方法，为<strong>twisted Edwards曲线</strong>规定了twisted Edwards Elligator 2方法。对<strong>Weierstrass曲线</strong>，如<code class="language-plaintext highlighter-rouge">secp256k1</code>，有如下三种选择：</p>

<ol>
  <li><strong>Shallue-van de Woestijne (SW) 方法</strong>，适用于任意椭圆曲线，但是最慢的。</li>
  <li><strong>Simplified Shallue-van de Woestijne-Ulas (SSWU) 方法</strong>，适用于定义为 $y^2=x^3+A x+B$ （其中 $A \neq 0,B \neq 0$）的曲线。</li>
  <li>应用在$A B$ 等于0的曲线的<strong>Simplified SWU 方法</strong> 。这是这三种方法中最高效的。</li>
</ol>

<p>针对我们的目的，应用在$A B$ 等于0的曲线的Simplified SWU 方法是相关的，因为<code class="language-plaintext highlighter-rouge">secp256k1</code>曲线的定义中 $A=0$ 且 $B=7$，所以$A B=0$。</p>

<h3 id="clear_cofactor"><code class="language-plaintext highlighter-rouge">clear_cofactor</code></h3>
<p>这个函数将曲线上的一个点转换为素数阶子群中的一个点。要做到这一点，只需将该点与一个常数$h$（译者注：协因子cofactor）相乘。在<code class="language-plaintext highlighter-rouge">secp256k1</code>曲线的情况下，不需要做任何事情，因为这个曲线中$h$等于1。</p>

<h2 id="安全考虑">安全考虑</h2>
<p>任何哈希到曲线函数或其实现都应该具有特定的安全性质，以保持采用它的密码学协议的安全。否则，一个弱的哈希到曲线函数会使协议受到攻击。正如该标准草案所指出的，哈希到曲线函数不仅必须是抗碰撞的，而且不应暴露输出点的离散对数。</p>

<p>为了分析一个密码学协议的安全性，密码学家基于其组成部分的假设来写证明。这些理论上的假设可以被描述为模型。该标准草案的作者认为，他们的方法在所谓的<a href="https://link.springer.com/referenceworkentry/10.1007/978-1-4419-5906-5_220">随机预言模型</a> （ROM）中是安全的。因此，如果设计正确，依靠这种哈希到曲线函数的协议也可以在ROM中证明是安全的。</p>

<h3 id="随机预言模型">随机预言模型</h3>

<p>该标准草案的作者认为，他们的哈希到曲线算法在ROM中是安全的。这些函数通过两种方式实现这一点：确保算法通过哈希函数将输入信息转换为均匀随机的域元素，并确保哈希到曲线算法的输出曲线点在统计上是均匀的。</p>

<p>首先，<code class="language-plaintext highlighter-rouge">hash_to_field</code>过程依赖于一种将字节串扩展为均匀随机的字节串的方法。这个方法有两个变种：<code class="language-plaintext highlighter-rouge">expand_message_xof</code>和<code class="language-plaintext highlighter-rouge">expand_message_xmd</code>。</p>

<p><code class="language-plaintext highlighter-rouge">expand_message_xof</code>依赖于一个哈希函数，它原生提供了一个所需长度的输出。由于这个哈希函数（推荐用SHAKE XOF类）在ROM下是可证明安全的，因此很容易证明<code class="language-plaintext highlighter-rouge">hash_to_field</code>函数在ROM下也是安全的。</p>

<p><code class="language-plaintext highlighter-rouge">expand_message_xmd</code>则依赖于一个具有固定长度输出的哈希函数。虽然有些哈希函数与随机预言不可区分，或者说基于海绵的哈希函数，其内部函数可以证明是随机置换或随机变换，因此可以认为<code class="language-plaintext highlighter-rouge">expand_message_xmd</code>与随机预言不可区分，但有些哈希函数就不是这种情况，比如Merkle-Damgård哈希函数。</p>

<p>该标准草案引用了Coron等人在<a href="https://cs.nyu.edu/~dodis/ps/merkle.pdf">CDMP05</a> 中的观点，认为像SHA这样的哈希函数所采用的增强Merkle-Damgård变换不满足以下安全性质：</p>

<p class="info">当固定长度的构造组件被看作是一个随机预言或一个理想分组加密（ideal block-cipher）时，任意长度的哈希函数$H$一定会表现得像一个随机预言。</p>

<p>为了让<code class="language-plaintext highlighter-rouge">expand_message_xmd</code>在 ROM 中证明安全且使用像 <code class="language-plaintext highlighter-rouge">SHA256</code> 这样的 Merkle-Damgård 哈希函数，作者在 CDMP05 中（第12页）使用了一个名为 <strong>HMAC</strong> $^f$ 的构造。 这种构造的粗略描述（为简单起见跳过了后缀填充步骤）如下：</p>
<ol>
  <li>令$k$ 为Merkle-Damgård哈希函数$\mathrm{MD}^f$ 所要求的输入字节个数，$m$为消息。</li>
  <li>令$m_0$ 为$k$个0的字节数组。</li>
  <li>令 $y^{\prime}=\mathrm{MD}^f\left(\left[m_0 | m\right]\right)$ 其中 $|$ 指代级联。</li>
  <li>返回 $\mathrm{MD}^f\left(\left[y^{\prime}\right]\right)$</li>
</ol>

<p class="info">回顾<strong>长度扩展攻击</strong>：当给定一个哈希值$h\left(m_a\right)$时，<em>即使不知道$m_a$的值</em>，敌手也能够通过平凡地实例化$h\left(m_a\right)$底层哈希的内部状态以导出$h\left(\left[m_a | m_b\right]\right)$。这违背了随机预言模型的一个关键性质——即一个消息  $\left(m_b\right)$  的哈希值不应该可以从另一个消息 $\left(m_a\right)$ 的哈希值中确定。</p>

<p>HMAC$^f$ 构造不受此问题的影响。 仅知道 $y^{\prime}$ 希望导出 $\operatorname{HMAC}^f([m | x])$ 的敌手不太可能成功。 考虑敌手可能的尝试：</p>

<ol>
  <li>得到 $a=\operatorname{HMAC}^f([m])$.
    <ul>
      <li>注意 $a$ 等价于 $\mathrm{MD}^f\left(\mathrm{MD}^f\left(\left[m_0 | m\right]\right)\right)$.</li>
    </ul>
  </li>
  <li>仅指导 $\mathrm{MD}^f$ 和 $y$，敌手想要导出 $b=\operatorname{HMAC}^f([m | x])$.
    <ul>
      <li>注意 $b$ 等价于 $\operatorname{MD}^f\left(\operatorname{MD}^f\left(\left[m_0|m| x\right]\right)\right)$.</li>
    </ul>
  </li>
  <li>敌手需要$\operatorname{MD}^f\left(\left[m_0 | m\right]\right)$ 等于$m_0$以使其可以用$m_0$实例化$\mathrm{MD}^f$ 的内部状态，然后在$x$上处理$\mathrm{MD}^f$ 的其余部分以得到$\operatorname{MD}^f\left(\left[m_0|m| x\right]\right)$。</li>
  <li>然而， $\operatorname{MD}^f\left(\left[m_0 | m\right]\right)$ 等于$m_0$是极不可能的。</li>
</ol>

<p>因此，$\operatorname{HMAC}^f([m])$ 不会受到长度扩展攻击，因此更容易在 ROM 下被证明是安全的。</p>

<p><code class="language-plaintext highlighter-rouge">expand_message_xmd</code> 实现了这种构造，通常称为<a href="https://en.wikipedia.org/wiki/HMAC"><strong>基于哈希的消息认证码 (HMAC)</strong></a>。 作为参考，请注意其实现遵循以下模式。 对使用 <code class="language-plaintext highlighter-rouge">SHA256</code> 并需要 96 字节输出的哈希到曲线密码套件，<code class="language-plaintext highlighter-rouge">expand_message_xmd</code> 大致定义如下：</p>

<ol>
  <li>令 <code class="language-plaintext highlighter-rouge">Z_pad</code> 为 64 个零的字节数组（因为对于 SHA256，$k=64$）。 这类似于上述的 $m_0$。</li>
  <li><code class="language-plaintext highlighter-rouge">msg_prime</code> 构造为 <code class="language-plaintext highlighter-rouge">Z_pad</code>、消息和一些常量例如 <code class="language-plaintext highlighter-rouge">DST_prime</code>的级联。</li>
  <li>计算 <code class="language-plaintext highlighter-rouge">b_0 = SHA256 (msg_prime)</code>。 这类似于如上所述的 $y^{\prime}$。</li>
  <li>计算 <code class="language-plaintext highlighter-rouge">b_1 = SHA256 (b_0 || 1|| DST_prime )</code>。</li>
  <li>计算 <code class="language-plaintext highlighter-rouge">b_2 = SHA256 (strxor(b_0, b_1) || 2 || DST_prime)</code>。</li>
  <li>计算 <code class="language-plaintext highlighter-rouge">b_3 = SHA256 (strxor(b_0, b_2) || 3 || DST_prime)</code>。</li>
  <li>返回 <code class="language-plaintext highlighter-rouge">b_1 || b_2 || b_3</code>。</li>
</ol>

<p>如上所述，在步骤 2 中添加 <code class="language-plaintext highlighter-rouge">Z_pad</code> 可以防止长度扩展攻击，该攻击可使敌手更容易影响 <code class="language-plaintext highlighter-rouge">b_1</code>、<code class="language-plaintext highlighter-rouge">b_2</code> 和 <code class="language-plaintext highlighter-rouge">b_3</code> 的值。</p>

<h3 id="域分隔">域分隔</h3>
<p>读者可能会注意到上面 <code class="language-plaintext highlighter-rouge">expand_message_xmd</code> 算法中的 <code class="language-plaintext highlighter-rouge">DST_prime </code>常量，它编码了表示<strong>域分隔标记 (DST)</strong> 的字节串，后跟 DST 长度作为单个字节。 每个密码套件都有一个唯一的 DST，例如 <code class="language-plaintext highlighter-rouge">secp256k1_XMD:SHA-256_SSWU_RO_</code> 套件的 <code class="language-plaintext highlighter-rouge">QUUX-V01-CS02-with-secp256k1_XMD:SHA-256_SSWU_RO_</code>。
在 <code class="language-plaintext highlighter-rouge">expand_message_xmd</code> 中包含唯一<code class="language-plaintext highlighter-rouge"> DST_prime</code> 的原因是为了确保其输出特定于唯一一个密码套件。 实际上，每个密码套件都可以理解为与独立的随机预言一起运行，这是在随机预言模型下被证明是安全的协议的<a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#section-2.2.5">重要安全假设</a>。</p>

<h3 id="输出均匀性">输出均匀性</h3>

<p>在标准草案中，每条椭圆曲线都带有两个密码套件：一个执行<strong>哈希到曲线</strong>，另一个执行<strong>编码到曲线</strong>。两者的区别在于前者函数的输出在统计上比后者更均匀，但后者的效率更高。作者指出，安全的默认设置是使用哈希到曲线，除非有人确定在自己的密码协议中可以接受不均匀性。</p>

<p>哈希到曲线不同的原因在于它的实现。 哈希到曲线函数从输入消息中导出两个不同的椭圆曲线点（使用 <code class="language-plaintext highlighter-rouge">map_to_curve</code> 函数）并将它们相加。相比之下，编码到曲线函数只调用一次 <code class="language-plaintext highlighter-rouge">map_to_curve</code>。由于 <code class="language-plaintext highlighter-rouge">map_to_curve </code>的输出是非均匀的，因此编码到曲线的输出是非均匀的。但由于哈希到曲线对两个非均匀点进行了点加，因此输出是均匀的。作者引用了 <a href="https://eprint.iacr.org/2009/340.pdf">Brier 等人</a> 的文章，证明情况确实如此。</p>

<h3 id="常数时间实现">常数时间实现</h3>

<p>标准草案中哈希到曲线密码套件的一个重要安全性质就是可以<em>在常数时间内</em>计算。如果要哈希的消息需要保密的，则此性质至关重要。</p>

<p>拥有安全的常数时间哈希到曲线函数是重要的进展，因为之前关于哈希到曲线算法的许多工作都使用了<strong>尝试-增量方法</strong>，输入消息被转换为域元素，测试它是否是曲线中有效的 $x$ 坐标，如果不是，则递增并重复测试。</p>

<p>这种尝试-增量方法的缺点有两方面。首先，即使在 $n-x$ 次尝试中已经找到了有效点，也必须执行到特定次数 $n$。这是为了防止<strong>侧信道时序攻击</strong>。其次，总是存在 $n$ 不够大的可能性，因此必须使用新消息再次尝试。处理这些情况所需的额外复杂性可能会导致协议中出现安全漏洞的可能性更大，如在 WPA3 和 EAP-pwd 协议的实现中发现的 <a href="https://eprint.iacr.org/2019/383">Dragonblood 漏洞</a> 中所见。</p>

<h2 id="结论">结论</h2>

<p>在这篇文章中，我概述了<strong>哈希到椭圆曲线</strong>的作者提出的各种安全和性能考虑。 我相信一组设计良好且安全的哈希到曲线密码套件将极大地有益于密码学领域，因为这些函数是许多重要协议的核心。 为此，有必要对本标准草案进行更具建设性的审查。</p>]]></content><author><name>Kurt Pan</name></author><category term="secp256k1曲线" /><category term="哈希到曲线" /><summary type="html"><![CDATA[原文：Hashing to the secp256k1 Elliptic Curve 作者：weijie.eth 译者：Kurt Pan 许多密码学协议，比如可聚合分布式密钥生成和BLS签名方案，都需要用到哈希到曲线算法，确定性地将任意字节串转换成椭圆曲线上的一个点。这样的算法并非平凡，因为不仅仅是要产生有效的曲线点，而且还要以安全且高效的方式来产生。 这篇文章中，我将总结哈希到曲线函数的技术现状，重点是其在secp256k1椭圆曲线上的应用，以及一般的哈希到曲线算法背后的一些安全考虑和性能优化。]]></summary></entry><entry><title type="html">配对或双线性映射</title><link href="http://localhost:4000/2023/02/22/pairings-or-bilinear-maps.html" rel="alternate" type="text/html" title="配对或双线性映射" /><published>2023-02-22T08:00:00+08:00</published><updated>2023-02-22T08:00:00+08:00</updated><id>http://localhost:4000/2023/02/22/pairings-or-bilinear-maps</id><content type="html" xml:base="http://localhost:4000/2023/02/22/pairings-or-bilinear-maps.html"><![CDATA[<blockquote>
  <ul>
    <li>原文：<a href="https://alinush.github.io/2022/12/31/pairings-or-bilinear-maps.html">Pairings or bilinear maps</a></li>
    <li>作者：Alin Tomescu</li>
    <li>译者：Kurt Pan</li>
  </ul>
</blockquote>

<!-- TODO: Add example of pairing (insecure). -->

<p class="info"><strong>摘要：</strong> <em>配对</em>，或者<em>双线性映射</em>，是对密码学来说非常强大的一个数学工具。配对给我们带来了最简洁的零知识证明<sup id="fnref:GGPR12e" role="doc-noteref"><a href="#fn:GGPR12e" class="footnote" rel="footnote">1</a></sup>$^,$<sup id="fnref:PGHR13e" role="doc-noteref"><a href="#fn:PGHR13e" class="footnote" rel="footnote">2</a></sup>$^,$<sup id="fnref:Grot16" role="doc-noteref"><a href="#fn:Grot16" class="footnote" rel="footnote">3</a></sup>，最高效的门限签名<sup id="fnref:BLS01" role="doc-noteref"><a href="#fn:BLS01" class="footnote" rel="footnote">4</a></sup>，第一个可用的身份基加密（IBE）方案<sup id="fnref:BF01" role="doc-noteref"><a href="#fn:BF01" class="footnote" rel="footnote">5</a></sup> ，以及其它很多高效的密码系统<sup id="fnref:KZG10" role="doc-noteref"><a href="#fn:KZG10" class="footnote" rel="footnote">6</a></sup>。本文中，我将介绍一点配对的性质，其密码学应用和令人着迷的历史。事实上，读完此文后，<a href="#历史">你可能会想要去监狱里待上个一两年</a>。</p>

<!--more-->

<p class="warning"><strong>关于推文的订正：</strong>我在发布这篇文章的<a href="https://twitter.com/alinush407/status/1612518576862408705">原始推文</a>中说到”没有【配对】，<strong>S</strong>NARKs就不可能”，这里加粗了 <strong>S</strong> 以强调这些SNARKs的“简洁性”。然而，感谢<a href="#致谢">推特上的一些大佬</a>，我意识到这并<strong>不</strong>完全正确，而要依赖于一个人说“简洁”时他到底是什么意思。具体来说，Gentry和Wichs<sup id="fnref:GW10" role="doc-noteref"><a href="#fn:GW10" class="footnote" rel="footnote">7</a></sup>的<em>多项式对数证明大小</em>意义上的”简洁“SNARKs，存在于很多假设之上，包括离散对数<sup id="fnref:BCCplus16" role="doc-noteref"><a href="#fn:BCCplus16" class="footnote" rel="footnote">8</a></sup>和随机谕言<sup id="fnref:Mica98" role="doc-noteref"><a href="#fn:Mica98" class="footnote" rel="footnote">9</a></sup>。此外，$O(1)$群元素证明大小意义上的”简洁“SNARKs，也存在于RSA假设之上<sup id="fnref:LM18" role="doc-noteref"><a href="#fn:LM18" class="footnote" rel="footnote">10</a></sup>。当前，配对给予我们的，是具有最小的具体证明大小（即按照字节数计算）的SNARKs。</p>

<p hidden="">$$
\def\idt{\mathbb{1}_{\Gr_T}}
\def\msk{\mathsf{msk}}
\def\dsk{\mathsf{dsk}}
\def\mpk{\mathsf{mpk}}
$$</p>

<h2 id="预备知识">预备知识</h2>

<ul>
  <li>熟悉素数阶循环群（例如椭圆曲线）</li>
  <li>令 \(\idt\) 表示群 $\Gr_T$ 的单位元</li>
  <li>令 $x \randget S$ 表示从集合 $S$ 中随机抽取一个元素 $x$</li>
  <li>回顾 $\langle g \rangle = \Gr$ 表示 $g$ 是群 $\Gr$ 的生成元</li>
</ul>

<h2 id="配对的定义">配对的定义</h2>
<p><em>配对</em>，也称为<em>双线性映射</em>，是一个在素数阶 $p$ 的三个群 $\Gr_1、\Gr_2$ 和 $\Gr_T$ 之间的函数 $e : \Gr_1 \times \Gr_2 \rightarrow \Gr_T$ ，其中生成元 $g_1 = \langle \Gr_1 \rangle，g_2 = \langle \Gr_2 \rangle$ ， $g_T = \langle \Gr_T \rangle$。</p>

<p>当 $\Gr_1 = \Gr_2$ 时，称为 <strong>对称</strong>配对。 否则，是<strong>非对称</strong>配对。</p>

<p>最重要的是，配对有两个对密码学有用的性质：<em>双线性</em>和<em>非退化性</em>。</p>

<h3 id="双线性性">双线性性</h3>

<p><em>双线性性</em>要求，对于所有 $u\in\Gr_1$、$v\in\Gr_2$ 和 $a,b\in\Zp$，有：
\(e(u^a, v^b) = e(u, v)^{ab}\)</p>

<p class="warning">考虑密码学，这是<strong>最酷</strong>的一个性质。 例如，这正是使<a href="#三方diffie-hellman">三方Diffie-Hellman</a> 等有用应用成为可能的原因。</p>

<h3 id="非退化性">非退化性</h3>
<p><em>非退化性</em>要求：
\(e(g_1, g_2) \ne \idt\)</p>

<p class="info"><strong>为什么有这个性质？</strong> 我们需要非退化性是因为没有它的话，定义一个（退化的）双线性映射是非常简单的（但没有用）。对于每个输入，返回 $\idt$即可。 这样的映射将满足双线性，但完全没有用。</p>

<h3 id="高效性">高效性</h3>
<p><em>高效性</em>要求存在群元素的大小（即 $\lambda = \log_2{p}$ 中）上的多项式时间算法，可用于求出任意输入上的配对 $e$。</p>

<details>
<summary><b>为什么要有这个要求</b> 排除了平凡但计算上困难的配对。 <i>（点击展开。）</i></summary>
<p style="margin-left: .3em; border-left: .15em solid black; padding-left: .5em;">
例如，假设 $r$ 是 $\Gr_T$ 中的一个随机元素。
首先，将配对定义为 $e(g_1, g_2) = r$。
这样，配对满足<em>非退化性</em>。
<br /><br />

其次，给定 $(u,v)\in \Gr_1 \times \Gr_2$，算法可以花费指数时间 $O(2^\lambda)$ 来计算离散对数 $x = \log_ {g_1}{(u)}$ 和 $y = \log_{g_2}{(v)}$ 并返回 $e(u, v) = e(g_1^x, g_2^y) = r^{xy}$。
这样，配对满足<em>双线性性</em>因为：
<br /><br />

\begin{align}
e(u^a, v^b)
    &amp;= e\left((g_1^x)^a, (g_2^y)^b\right)\\\
    &amp;= e\left(g_1^{(ax)}, g_2^{(by)}\right)\\\
    &amp;= r^{(ax)\cdot (by)}\\\
    &amp;= \left(r^{xy}\right)^{ab}\\\
    &amp;= e(u, v)^{ab}
\end{align}
</p>
</details>

<h2 class="warning" id="历史">历史</h2>
<p>这是我对配对历史的有限理解，主要来自 <a href="https://www.youtube.com/watch?v=1RwkqZ6JNeo">此视频中 Dan Boneh 的叙述</a> 以及我自己对相关文献的研究。 如果你知道更多历史，请给我发电子邮件，我可以尝试将其合并。</p>

<h3 id="监狱里的数学家">监狱里的数学家</h3>
<p>（密码学）配对的历史始于一位名叫 <strong>André Weil</strong><sup id="fnref:Wiki22Weil" role="doc-noteref"><a href="#fn:Wiki22Weil" class="footnote" rel="footnote">11</a></sup> 的数学家，他在二战期间因拒绝在法国军队服役而入狱。
在那里，Weil，“设法说服了思想开明的监狱长将 [他] 关在一个单独的牢房里，[他] 被允许保留 [..] 笔、墨水和纸。”</p>

<p>Weil 使用这些他新获得的工具定义出了跨两个椭圆曲线群的配对。
<strong>然而</strong>，当时看来可能<strong>非常奇怪</strong>的是，Weil 付出了很多努力来确保他对配对的定义是<em>可计算的</em>。
这种额外的努力使今天基于配对的密码学成为了可能<sup id="fnref:danboneh-shimuranote" role="doc-noteref"><a href="#fn:danboneh-shimuranote" class="footnote" rel="footnote">12</a></sup>。</p>

<h3 id="去监狱不去大学">去监狱，不去大学？</h3>
<p>有趣的是，韦尔在监狱里的时间是如此高效，以至于他开始考虑是否应该每年在那里度过几个月。
更绝的是，Weil 考虑他是否应该<strong>向有关当局建议每个数学家都要在监狱里度过一段时间。</strong>
Weil 写道：</p>

<blockquote>
  <p>我开始认为没有什么比监狱更有利于抽象科学了。</p>

  <p>[…]</p>

  <p>我的数学工作进展出乎我的意料，我甚至有点担心——如果我只是在监狱里学得这么好，我是否每年都要安排关押两三个月？</p>

  <p>与此同时，我正在考虑向有关当局写一份报告，如下：“致科学研究主任：最近经由个人经验发现了一个可以对纯粹和无私的研究提供相当大的优势的方法，即留在监狱系统的设施中，我冒昧地请求……。”</p>
</blockquote>

<p>你可以在他引人入胜的自传中读到所有这些以及更多的内容，该自传是从他作为数学家的角度写成的<sup id="fnref:Weil92" role="doc-noteref"><a href="#fn:Weil92" class="footnote" rel="footnote">13</a></sup>。</p>

<h3 id="从破解密码学到构建密码学">从破解密码学到构建密码学</h3>

<p>Weil 的工作是基础。
但是，基于配对的密码学的兴起还需要三个进展。</p>

<h4 id="第一个进展miller算法">第一个进展：Miller算法</h4>
<p>1985 年，<strong>Victor Miller</strong> 撰写了一份手稿，表明实际上可以在多项式时间内有效地计算 Weil 配对（其本身实际上涉及指数阶多项式求值） <sup id="fnref:Mill86Short" role="doc-noteref"><a href="#fn:Mill86Short" class="footnote" rel="footnote">14</a></sup>。</p>

<p>1984 年 12 月，Miller在 IBM 发表了关于椭圆曲线密码学的演讲，他声称椭圆曲线离散对数比有限域上的普通离散对数更难计算 <sup id="fnref:miller-talk" role="doc-noteref"><a href="#fn:miller-talk" class="footnote" rel="footnote">15</a></sup>。
Miller 受到了在场的 Manuel Blum 的挑战，要求他通过<a href="https://en.wikipedia.org/wiki/Reduction_(complexity)">归约</a> 来支持这一说法：即，表明用于求解椭圆曲线上的离散对数的算法$B$可以有效地转换为另一种用于求解有限域中的离散对数的算法$A$。
这种归约意味着$B$解决的问题（即计算椭圆曲线离散对数）至少与$A$解决的问题（即计算有限域离散对数）一样难，如果不是更难的话。</p>

<p>Miller 着手通过思考唯一能将椭圆曲线群和有限域关联起来的事物–Weil配对，来试图找到归约。
有趣的是，他很快意识到，虽然 Weil 配对给出了一个归约，但是在相反的方向上的：即事实上，在 Weil 配对的帮助下，有限域中离散对数的算法 $A$ 可以有效地转化为椭圆曲线中的离散对数的算法 $B$ 。
这种“不想要的”的归约可以很容易看出来。
由于 $e(g^a, g) = e(g,g)^a$，求解椭圆曲线元素 $g_a\in \Gr$ 上的离散对数只要求解 $e(g,g )^a\in \Gr_T$，它实际上是有限域的乘法子群（参见 <a href="#配对到底是怎么做的">配对到底是怎么做的？</a>）。</p>

<p>这几乎与 Miller 试图证明的相反，可能会使得整个椭圆曲线密码学崩溃，但幸运的是，Weil 配对映射到的扩域的阶太大，使得这种“不想要的”归约效率低下，因此也就根本不是一个归约。</p>

<p>整个事件让 Miller 对是否可以高效地计算 Weil 配对产生了兴趣，这导致了他算法的发现。
有趣的是，他将这篇手稿投给了顶级理论计算机科学会议 FOCS，但这篇论文被拒了，直到很久以后才发表在JoC上（根据 Miller 的说法）<sup id="fnref:alin-where" role="doc-noteref"><a href="#fn:alin-where" class="footnote" rel="footnote">16</a></sup>。</p>

<h4 id="第二个进展mov攻击">第二个进展：MOV攻击</h4>
<p>1991 年，<strong>Menezes、Vanstone 和 Okamoto</strong><sup id="fnref:MVO91" role="doc-noteref"><a href="#fn:MVO91" class="footnote" rel="footnote">17</a></sup> 利用 Miller 的高效算法来求 Weil 配对，攻破了特定椭圆曲线上<strong>在亚指数时间内</strong>的离散对数假设。
这是非常惊人的，因为当时还没有已知的用于椭圆曲线的亚指数时间算法。</p>

<p class="info">他们的攻击称为<em>MOV 攻击</em>，将椭圆曲线离散对数挑战 $g^a\in\Gr$ 使用配对映射到<strong>目标群</strong> $e(g^a, g)=e(g,g)^ a \in \Gr_T$ 。
由于目标群是有限域 $\mathbb{F}_q^{k}$ 的子群，这就可以使用更快的亚指数时间算法来计算 $e(g,g)^a$ 上的离散对数。</p>

<h4 id="第三个进展joux的三方diffie-hellman">第三个进展：Joux的三方Diffie-Hellman</h4>
<p>到目前为止，配对似乎只对<strong>密码分析</strong>有用。
没有人知道如何使用它们来构造（而不是破解）密码学。</p>

<p>这在 2000 年发生了变化，那时 <strong>Joux</strong><sup id="fnref:Joux00" role="doc-noteref"><a href="#fn:Joux00" class="footnote" rel="footnote">18</a></sup> 使用配对在三方之间实现了单轮密钥交换协议，即 <a href="#三方diffie-hellman">三方Diffie-Hellman</a> 
以前，已知的这种单轮协议仅在两方之间，而三方需要 2 轮。</p>

<p>从那时开始，大量新的、高效的密码学开始涌现：</p>

<ul>
  <li>BLS（短）签名<sup id="fnref:BLS01:1" role="doc-noteref"><a href="#fn:BLS01" class="footnote" rel="footnote">4</a></sup></li>
  <li>基于身份的加密<sup id="fnref:BF01:1" role="doc-noteref"><a href="#fn:BF01" class="footnote" rel="footnote">5</a></sup></li>
  <li>支持一次乘法的加法同态加密<sup id="fnref:BGN05" role="doc-noteref"><a href="#fn:BGN05" class="footnote" rel="footnote">19</a></sup></li>
  <li>简洁零知识证明<sup id="fnref:GGPR12e:1" role="doc-noteref"><a href="#fn:GGPR12e" class="footnote" rel="footnote">1</a></sup></li>
</ul>

<p class="info">请注意这里有趣的模式：配对如何从用于破解密码系统的<em>密码分析工具</em>演变为用于构造密码系统的<strong>建设性工具</strong>的。
有趣的是，同样的模式也出现在了基于格的密码学的发展中。</p>

<h2 id="配对的算术技巧">配对的算术技巧</h2>
<p>在密码系统的正确性或安全性证明中处理配对时，密码学家经常会使用一些技巧。</p>

<p>最明显的技巧，<strong>“指数上相乘”</strong>，来自双线性性。</p>

<p>\begin{align}
e(u^a, v^b) = e(u, v)^{ab}
\end{align}</p>

<p>双线性性也蕴含着下述技巧：
\begin{align}
e(u, v^b) = e(u, v)^b
\end{align}
或者：
\begin{align}
e(u^a, v) = e(u, v)^a
\end{align}</p>

<p>另一个技巧如下，这只是定义双线性性的一种类似方式：
\begin{align}
e(u, v\cdot w) = e(u, v)\cdot e(u, w)
\end{align}</p>

<p class="info"><strong>为什么这是对的？</strong> 令 $y,z$ 分别表示 $v$ 和 $w$ 的离散对数 (关于 $g_2$的)。
然后，我们有：
\begin{align}
e(u, v\cdot w) 
    &amp;= e(u, g_2^y \cdot g_2^z)\\<br />
    &amp;= e(u, g_2^{y + z})\\<br />
    &amp;= e(u, g_2)^{y + z}\\<br />
    &amp;= e(u, g_2)^y \cdot e(u, g_2)^z\\<br />
    &amp;= e(u, g_2^y) \cdot e(u, g_2^z)\\<br />
    &amp;= e(u, v)\cdot e(u, w)
\end{align}</p>

<p>或者：
\begin{align}
e(u, v / w) = \frac{e(u, v)}{e(u, w)}
\end{align}</p>

<h2 id="配对的应用">配对的应用</h2>

<h3 id="三方diffie-hellman">三方Diffie-Hellman</h3>

<p>该协议由 Joux 在 2000 年 <sup id="fnref:Joux00:1" role="doc-noteref"><a href="#fn:Joux00" class="footnote" rel="footnote">18</a></sup> 引入，使用<strong>对称配对</strong>：即，其中 \(\Gr_1 = \Gr_2 = \langle g\rangle \stackrel{\mathsf{def}}{=} \Gr\)。</p>

<p>我们有三个参与方 Alice、Bob 和 Charles，他们分别拥有私钥 $a、b$ 和 $c$。
他们互相发送他们的公钥 $g^a, g^b, g^c$ 并得到共享密钥 $k = e(g, g)^{abc}$。<sup id="fnref:dhe" role="doc-noteref"><a href="#fn:dhe" class="footnote" rel="footnote">20</a></sup></p>

<p>怎么做到？</p>

<p>考虑Alice的视角。
她从 Bob 和 Charles 那里得到 $g^b$ 和 $g^c$。
首先，她可以使用她的秘密 $a$ 来计算 $g^{ab}$。
其次，她可以使用配对来计算 $e(g^{ab}, g^c) = e(g, g)^{abc} = k$。</p>

<p>通过对称性，所有其他参与者都可以做同样的事情并就相同的 $k$ 达成一致。</p>

<p class="info">该协议也可以推广到 <a href="#配对的定义"><strong>非</strong>对称配对</a>，其中 $\Gr_1 \neq \Gr_2$。</p>

<h3 id="bls-签名">BLS 签名</h3>

<p>Boneh、Lynn 和 Shacham 使用配对<sup id="fnref:BLS01:2" role="doc-noteref"><a href="#fn:BLS01" class="footnote" rel="footnote">4</a></sup> 给出了一个非常短的签名方案，其工作原理如下：</p>

<ul>
  <li>假设 $\Gr_2 = \langle g_2 \rangle$ 且存在一个哈希函数 $H : \{0,1\}^* \rightarrow \Gr_1$ ，建模为随机谕言。</li>
  <li>私钥是 $s \in \Zp$ 而公钥是 $\pk = g_2^s \in \Gr_2$。</li>
  <li>要对消息 $m$ 签名，签名者计算 $\sigma = H(m)^s\in \Gr_1$。</li>
  <li>要在公钥 $\pk$ 下验证 $m$ 上的签名 $\sigma$，检查 $e(\sigma, g_2) \stackrel{?}{=} e(H(m), \pk) $ 是否成立。</li>
</ul>

<p>请注意，正确计算的签名将始终可以通过验证，因为：
\begin{align}
e(\sigma, g_2) \stackrel{?}{=} e(H(m), \pk) \Leftrightarrow\\<br />
e(H(m)^s, g_2) \stackrel{?}{=} e(H(m), g_2^s) \Leftrightarrow\\<br />
e(H(m), g_2)^s \stackrel{?}{=} e(H(m), g_2)^s \Leftrightarrow\\<br />
e(H(m), g_2) = e(H(m), g_2)
\end{align}</p>

<p>请参阅 BLS 论文 <sup id="fnref:BLS01:3" role="doc-noteref"><a href="#fn:BLS01" class="footnote" rel="footnote">4</a></sup>，关于如何证明没有攻击者可以在访问 $\pk$ 和签名谕言的情况下伪造 BLS 签名。</p>

<h4 id="bls签名的酷炫性质">BLS签名的酷炫性质</h4>
<p>BLS 签名非常棒：</p>

<ol>
  <li>如果可以访问椭圆曲线库，它是实现<strong>最简单</strong>的方案之一。</li>
  <li>可以<strong>聚合</strong>同一消息 $m$ 上来自不同公钥的许多签名到一个单一的<em>多重签名</em>中，继续仅使用 2 个配对验证。</li>
  <li>甚至可以将不同消息中的此类签名<strong>聚合</strong>为一个<em>聚合签名</em>。
    <ul>
      <li>然而，这样的聚合签名需要 $n+1$ 个配对来验证。</li>
    </ul>
  </li>
  <li>可以轻松高效地<sup id="fnref:TCZplus20" role="doc-noteref"><a href="#fn:TCZplus20" class="footnote" rel="footnote">21</a></sup>构造<strong>门限</strong>BLS签名方案，其中$n$个签名者中$\ge t$的任意子集可以协作签署消息$m$，但没有少于 $t$ 的子集可以产生有效的签名。
    <ul>
      <li>更好的是，BLS 门限签名是<strong>确定性的</strong>，从而支持<em>门限可验证随机函数 (VRF)</em>，这对于在链上生成随机性很有用。</li>
    </ul>
  </li>
  <li>可以定义非常高效的 BLS 签名的 <strong>盲化</strong> 变体，其中签名者可以在不知道消息 $m$ 的情况下签署消息 $m$。</li>
  <li>BLS签名在实践中非常<strong>高效</strong>。
    <ul>
      <li>据我所知，是 (1) 多重签名、(2) 聚合签名和 (3) 门限签名的最高效的方案</li>
      <li>对于单签名者 BLS，在非配对友好曲线上比 Schnorr 签名慢</li>
    </ul>
  </li>
</ol>

<p class="warning">如果你对多重签名、聚合签名和门限签名的各种概念感到困惑，请参阅<a href="https://docs.google.com/presentation/d/1G4XGqrBLwqMyDQce_xpPQUEMOK4lFrneuvGYU3MVDsI/edit?usp=sharing">我的幻灯片</a>。</p>

<h3 id="身份基加密-ibe">身份基加密 (IBE)</h3>

<p>在 IBE 方案中，可以直接用用户友好的电子邮件地址（或电话号码）来加密，而不是用难以记住或正确输入的繁琐公钥。</p>

<p>Boneh 和 Franklin 基于配给出了一个非常有效的 IBE 方案 <sup id="fnref:BF01:2" role="doc-noteref"><a href="#fn:BF01" class="footnote" rel="footnote">5</a></sup>。</p>

<p>IBE正常运作必须引入一个称为<strong>私钥生成者 (PKG)</strong> 的可信第三方 (TTP)，该第三方将根据用户的电子邮件地址向用户颁发密钥。
这个 PKG 有一个 <strong>主密钥 (MSK)</strong> $\msk \in \Zp$ 和一个关联的 <strong>主公钥 (MPK)</strong> $\mpk = g_2^s$，其中 $\langle g_2 \rangle = \Gr_2$。</p>

<p>$\mpk$ 是公开的，可用于给任意用户（给定电子邮件地址）加密消息。
至关重要的是，PKG 必须对 $\msk$ 保密。
否则，窃取它的攻击者可以导出任何用户的密钥并解密每个人的消息。</p>

<p class="warning">如你所知，PKG 是一个中心故障点：盗窃 $\msk$ 会危及每个人的机密。
为了缓解这种情况，可以将 PKG 分散到多个权威机构中，这样就必须攻破一定数量的权威机构才能窃取 $\msk$。</p>

<p>令 $H_1 : \{0,1\}^* \rightarrow \Gr_1^*$ 和 $H_T : \Gr_T \rightarrow \{0,1\}^n$ 是两个哈希函数，建模为随机谕言。
要加密发送给电子邮件地址为 $id$ 的用户的 $n$ 比特消息 $m$，需要计算：
\begin{align}
    g_{id} &amp;= e(H_1(id), \mpk) \in \Gr_T\\<br />
    r &amp;\randget \Zp\\<br />
    \label{eq:ibe-ctxt}
    c &amp;= \left(g_2^r, m \xor H_T\left(\left(g_{id}\right)^r\right)\right) \in \Gr_2\times \{0,1\}^n
\end{align}</p>

<p>要解密，电子邮件地址为 $id$ 的用户必须首先从 PKG 获取他们的<strong>解密密钥</strong> $\dsk_{id}$。
为此，我们假设 PKG 有一种方法可以在将密钥交给用户之前对用户进行身份验证。
例如，这可以通过电子邮件完成。</p>

<p>PKG 将用户的解密密钥计算为：
\begin{align}
    \dsk_{id} = H_1(id)^s \in \Gr_1
\end{align}</p>

<p>现在用户有了他们的解密密钥，他们可以将方程 $\ref{eq:ibe-ctxt}$ 中的密文 $c = (u, v)$ 解密为：
\begin{align}
    m &amp;= v \xor H_T(e(\dsk_{id}, u))
\end{align}</p>

<p>你可以看到为什么正确加密的密文将成功解密，因为：
\begin{align}
v \xor H_T(e(\dsk_{id}, u))
    &amp;= \left(m \xor       H_T\left((g_{id})^r            \right)\right) \xor H_T\left(e(H_1(id)^s, g_2^r)     \right)\\<br />
    &amp;= \left(m \xor       H_T\left(e(H_1(id), \mpk )^r   \right)\right) \xor H_T\left(e(H_1(id),   g_2  )^{rs}\right)\\<br />
    &amp;=       m \xor \left(H_T\left(e(H_1(id), g_2^s)^r   \right)        \xor H_T\left(e(H_1(id),   g_2  )^{rs}\right)\right)\\<br />
    &amp;=       m \xor \left(H_T\left(e(H_1(id), g_2  )^{rs}\right)        \xor H_T\left(e(H_1(id),   g_2  )^{rs}\right)\right)\\<br />
    &amp;= m
\end{align}</p>

<p>要了解为什么该方案在选择明文攻击下是安全的，请参阅原始论文<sup id="fnref:BF01:3" role="doc-noteref"><a href="#fn:BF01" class="footnote" rel="footnote">5</a></sup>。</p>

<h2 id="配对到底是怎么做的">配对到底是怎么做的？</h2>
<p>大多数情况下，我也完全不知道。
怎么会呢？
好吧，我真的不需要知道。
这正是配对的美妙之处：人们可以以一种黑盒方式使用它们，而对其内部结构的了解为零。</p>

<p>不过，让我们来看一下这个黑盒子的内部。
让我们考虑流行的配对友好曲线 <em>BLS12-381</em> <sup id="fnref:Edgi22" role="doc-noteref"><a href="#fn:Edgi22" class="footnote" rel="footnote">22</a></sup>，它来自以 Barreto、Lynn 和 Scott 命名的 BLS 曲线家族 <sup id="fnref:BLS02e" role="doc-noteref"><a href="#fn:BLS02e" class="footnote" rel="footnote">23</a></sup>。</p>

<p class="warning"><strong>公共服务声明：</strong>
你们中的一些人可能听说过<em>Boneh-Lynn-Shacham (BLS)</em> 签名。 请注意，这与 <em>Barretto-Lynn-Scott</em> 曲线中的 BLS 不同。 令人困惑的是，这两个首字母缩略词都有一个共同的作者，Ben Lynn。 （如果这还不够令人困惑，等你必须在 BLS12-381 曲线上使用 BLS 签名时就知道了。）</p>

<p>对于BLS12-381，涉及到的三个群$\Gr_1, \Gr_2, \Gr_T$分别是：</p>

<ul>
  <li>群 $\Gr_1$ 是椭圆曲线 $E(\F_q) = \left\{(x, y) \in (\F_q)^2\ \vert\ y^2 = x ^3 + 4 \right\}$的子群， 其中 $\vert\Gr_1\vert = p$</li>
  <li>群 $\Gr_2$ 是一个不同的椭圆曲线$E’(\F_{q^2}) = \left\{(x, y) \in (\F_{q^2} )^2\ \vert\ y^2 = x^3 + 4(1+i) \right\}$的子群，其中 $i$ 是 $-1$ 的平方根且 $\vert\Gr_2\vert = p $。</li>
  <li>群 $\Gr_T$ 是 $\F_{q^{k}}$ 中的所有的第 $p$ 个单位根，其中 $k=12$ 称为<em>嵌入度</em></li>
</ul>

<p>那么这三个群的配对映射是如何工作的？ 配对 $e(\cdot,\cdot)$ 可以展开为如下内容：
\begin{align}
\label{eq:pairing-def}
e(u, v) = f_{p, u}(v)^{(q^k - 1)/p}
\end{align}</p>

<p>知道计算配对包括两个步骤是很有用的：</p>

<ol>
  <li>求出基 $f_{p, u}(v)$，也称为 <strong>Miller 循环</strong>，以纪念 <a href="#历史">Victor Miller 的工作</a></li>
  <li>基于这个基上求常数的 $(q^k - 1)/p$作为指数，也称为<strong>最终指数</strong>。
    <ul>
      <li>这一步比第一步昂贵几倍</li>
    </ul>
  </li>
</ol>

<p>有关内部结构的更多信息，请参阅其他资源 <sup id="fnref:Cost12" role="doc-noteref"><a href="#fn:Cost12" class="footnote" rel="footnote">24</a></sup>$^,$<sup id="fnref:GPS08" role="doc-noteref"><a href="#fn:GPS08" class="footnote" rel="footnote">25</a></sup>$^,$<sup id="fnref:Mene05" role="doc-noteref"><a href="#fn:Mene05" class="footnote" rel="footnote">26</a></sup>。</p>

<h2 id="基于配对密码学的实现">基于配对密码学的实现</h2>
<p>本节讨论从业者可以用来加速实现的各种实现级细节。</p>

<h3 id="使用非对称配对">使用非对称配对！</h3>

<p>BLS12-381 上的配对是<strong>非对称</strong>的：即，$\Gr_1\ne\Gr_2$ 是两个<strong>不同的</strong>群（相同的阶 $p$）。 但是，也存在<strong>对称</strong>配对，其中 $\Gr_1 = \Gr_2$ 是同一个群。</p>

<p>不幸的是，“这种对称配对只存在于超奇异曲线上，这对协议的效率和安全性都会产生严重限制”<sup id="fnref:BCMplus15e" role="doc-noteref"><a href="#fn:BCMplus15e" class="footnote" rel="footnote">27</a></sup>。
换句话说，这种超奇异曲线在相同安全级别上不如<strong>非</strong>对称配对中使用的曲线高效。</p>

<p>因此，据我所知，今天的从业者完全依赖<strong>非</strong>对称配对，因为它们在安全级别保持不变时效率更高。</p>

<h3 id="bls12-381-性能">BLS12-381 性能</h3>

<p>我将为在 Filecoin 的 (<a href="https://github.com/filecoin-project/blstrs">blstrs</a> 中实现的 BLS12-381 曲线提供一些关键性能的数据，blstrs是流行的<a href="https://github.com/supranational/blst">blst</a>库的一个Rust包裹。</p>

<p>这些微基准测试使用<code class="language-plaintext highlighter-rouge">cargo bench</code>，在 10 核 2021 Apple M1 Max 上运行。</p>

<h4 id="配对计算时间">配对计算时间</h4>

<!--
	alinush@MacBook [~/repos/blstrs] (master %) $ cargo +nightly bench -- pairing_
	running 4 tests
	test bls12_381::bench_pairing_final_exponentiation     ... bench:     276,809 ns/iter (+/- 1,911)
	test bls12_381::bench_pairing_full                     ... bench:     484,718 ns/iter (+/- 2,510)
	test bls12_381::bench_pairing_g2_preparation           ... bench:      62,395 ns/iter (+/- 4,161)
	test bls12_381::bench_pairing_miller_loop              ... bench:     148,534 ns/iter (+/- 1,203)
-->

<p>正如式\ref{eq:pairing-def}中所解释的那样，配对涉及两个步骤：</p>

<ul>
  <li>Miller循环计算
    <ul>
      <li>210 微秒</li>
    </ul>
  </li>
  <li>最终指数
    <ul>
      <li>276 微秒</li>
    </ul>
  </li>
</ul>

<p>因此，一次配对大约需要 486 微秒（即两者之和）。</p>

<h4 id="求指数时间">求指数时间</h4>

<p class="warning">$\Gr_T$ 微基准测试是通过稍微修改<code class="language-plaintext highlighter-rouge">blstrs</code>的基准测试代码 （<a href="https://github.com/filecoin-project/blstrs/blob/e70aff6505fb6f87f9a13e409c080995bd0f244e/benches/bls12_381/ec.rs#L10">此处</a>） 完成的 。
（有关这些修改，请参阅本页的 HTML 注释。）</p>

<!--
	alinush@MacBook [~/repos/blstrs] (master *%) $ git diff
	diff --git a/benches/bls12_381/ec.rs b/benches/bls12_381/ec.rs
	index 639bcad..8dcec20 100644
	--- a/benches/bls12_381/ec.rs
	+++ b/benches/bls12_381/ec.rs
	@@ -167,3 +167,34 @@ mod g2 {
			 });
		 }
	 }
	+
	+mod gt {
	+    use rand_core::SeedableRng;
	+    use rand_xorshift::XorShiftRng;
	+
	+    use blstrs::*;
	+    use ff::Field;
	+    use group::Group;
	+
	+    #[bench]
	+    fn bench_gt_mul_assign(b: &mut ::test::Bencher) {
	+        const SAMPLES: usize = 1000;
	+
	+        let mut rng = XorShiftRng::from_seed([
	+            0x59, 0x62, 0xbe, 0x5d, 0x76, 0x3d, 0x31, 0x8d, 0x17, 0xdb, 0x37, 0x32, 0x54, 0x06,
	+            0xbc, 0xe5,
	+        ]);
	+
	+        let v: Vec<(Gt, Scalar)> = (0..SAMPLES)
	+            .map(|_| (Gt::random(&mut rng), Scalar::random(&mut rng)))
	+            .collect();
	+
	+        let mut count = 0;
	+        b.iter(|| {
	+            let mut tmp = v[count].0;
	+            tmp *= v[count].1;
	+            count = (count + 1) % SAMPLES;
	+            tmp
	+        });
	+    }
	+}
	alinush@MacBook [~/repos/blstrs] (master *%) $ cargo +nightly bench -- mul_assign
	   Compiling blstrs v0.6.1 (/Users/alinush/repos/blstrs)
		Finished bench [optimized] target(s) in 0.75s
		 Running unittests src/lib.rs (target/release/deps/blstrs-349120dc60ef3711)

	running 2 tests
	test fp::tests::test_fp_mul_assign ... ignored
	test scalar::tests::test_scalar_mul_assign ... ignored

	test result: ok. 0 passed; 0 failed; 2 ignored; 0 measured; 115 filtered out; finished in 0.00s

		 Running benches/blstrs_benches.rs (target/release/deps/blstrs_benches-a6732e3e4e5c6a4d)

	running 4 tests
	test bls12_381::ec::g1::bench_g1_mul_assign            ... bench:      72,167 ns/iter (+/- 1,682)
	test bls12_381::ec::g2::bench_g2_mul_assign            ... bench:     136,184 ns/iter (+/- 1,300)
	test bls12_381::ec::gt::bench_gt_mul_assign            ... bench:     497,330 ns/iter (+/- 7,802)
	test bls12_381::scalar::bench_scalar_mul_assign        ... bench:          14 ns/iter (+/- 0)

	test result: ok. 0 passed; 0 failed; 0 ignored; 4 measured; 21 filtered out; finished in 5.30s
-->

<ul>
  <li>$\Gr_1$ 求指数是最快的
    <ul>
      <li>72 微秒</li>
    </ul>
  </li>
  <li>$\Gr_2$ 求指数大约慢2倍
    <ul>
      <li>136 微秒</li>
    </ul>
  </li>
  <li>$\Gr_T$ 求指数比 $\Gr_2$ 慢大约3.5倍
    <ul>
      <li>500 微秒</li>
    </ul>
  </li>
</ul>

<p class="info"><strong>注意：</strong>这些基准测试随机选择取指数操作的基，并且<strong>不</strong>对其执行任何预计算，预计算会将这些时间加快 2-4 倍。</p>

<h4 id="多指数">多指数</h4>
<p>这是一个众所周知的优化，为了完整起见，我将其包括在内。</p>

<p>具体来说，许多库可以使得计算$k$ 次指数运算的乘积 $\prod_{0 &lt; i &lt; k} \left(g_i\right)^{x_i}$ 比单独计算 $k$ 次指数再聚合它们的乘积要快很多。</p>

<p>例如，<a href="https://github.com/filecoin-project/blstrs">blstrs</a> 在这方面似乎快得令人难以置信：</p>

<!--
running 4 tests
test bls12_381::bench_g1_multi_exp                     ... bench:     760,554 ns/iter (+/- 47,355)
test bls12_381::bench_g1_multi_exp_naive               ... bench:  18,575,716 ns/iter (+/- 42,688)
test bls12_381::bench_g2_multi_exp                     ... bench:   1,876,416 ns/iter (+/- 58,743)
test bls12_381::bench_g2_multi_exp_naive               ... bench:  35,272,720 ns/iter (+/- 266,279)
-->

<ul>
  <li>$\Gr_1$ 中的大小为 256 的多指数运算
    <ul>
      <li>总共需要 760 微秒，或者每次指数需要 3 微秒！</li>
      <li>朴素方法共需要 18.5 毫秒，慢24倍</li>
    </ul>
  </li>
  <li>$\Gr_2$ 中的大小为 256 的多指数运算
    <ul>
      <li>总共需要 1.88 毫秒，或者每次指数需要 7.33 微秒！</li>
      <li>朴素方法共需要 35.3 毫秒，慢18.8倍</li>
    </ul>
  </li>
</ul>

<h4 id="群元素大小">群元素大小</h4>
<ul>
  <li>$\Gr_1$群元素是最小的
    <ul>
      <li>例如，BLS12-381 为 48 字节， BN254 曲线为 32 字节<sup id="fnref:BN06Pair" role="doc-noteref"><a href="#fn:BN06Pair" class="footnote" rel="footnote">28</a></sup></li>
    </ul>
  </li>
  <li>$\Gr_2$ 群元素大2倍
    <ul>
      <li>例如，BLS12-381 为 96 字节</li>
    </ul>
  </li>
  <li>$\Gr_T$ 元素大 12 倍
    <ul>
      <li>通常，对于具有<em>嵌入度</em> $k$ 的配对友好曲线，大 $k$ 倍</li>
    </ul>
  </li>
</ul>

<h4 id="交换gr_1-和-gr_2">交换$\Gr_1$ 和 $\Gr_2$</h4>
<p>在设计基于配对的密码协议时，需要仔细考虑选择使用 $\Gr_1$ 和使用 $\Gr_2$ 的目的。</p>

<p>例如，在 BLS 签名中，如果想要更小的签名，那么应该计算签名 $\sigma = H(m)^s \in \Gr_1$ 并在 $\Gr_2$ 中设置稍大的公钥。
另一方面，如果想要最小化公钥大小，那么可以将它放在 $\Gr_1$ 中，同时花费较长的时间来计算 $\Gr_2$ 中的签名。</p>

<p class="warning">其他因素也会影响使用 $\Gr_1$ 和 $\Gr_2$ 的方式，例如同构 $\phi : \Gr_2 \rightarrow \Gr_1$ 的存在或均匀哈希到这些群中的能力。
事实上，这种同构的存在将非对称配对进一步分为两种类型：类型 2 和类型 3（有关不同类型配对的更多信息，请参阅 <em>Galbraith 等人</em><sup id="fnref:GPS08:1" role="doc-noteref"><a href="#fn:GPS08" class="footnote" rel="footnote">25</a></sup>）</p>

<h4 id="和非配对友好椭圆曲线的比较">和非配对友好椭圆曲线的比较</h4>
<p>与不支持配对的椭圆曲线相比，配对友好的椭圆曲线要慢两倍左右。</p>

<p>例如，流行的素数阶椭圆曲线群 <a href="https://ristretto.group/">Ristretto255</a> 提供：</p>

<!--
ristretto255/basepoint_mul
                        time:   [10.259 µs 10.263 µs 10.267 µs]

ristretto255/point_mul  time:   [40.163 µs 40.187 µs 40.212 µs]
-->

<ul>
  <li>求指数 40 微秒，快$\approx 2\times$
    <ul>
      <li>当基数固定时使用预计算可以加速到 10 微秒</li>
    </ul>
  </li>
  <li>群元素大小32 字节</li>
</ul>

<h3 id="多配对">多配对</h3>
<p>如果你还记得配对的实际工作方式（参见式 $\ref{eq:pairing-def}$），你会注意到以下优化：</p>

<p>每当我们必须计算 $n$ 个配对的乘积时，我们可以先计算 $n$ 次Miller循环并进行一次最终指数而不是 $n$ 次。
这大大减少了许多应用中的配对计算时间。</p>

<p>\begin{align}
\prod_i e(u_i, v_i)
    &amp;= \prod_i \left(f_{p, u_i}(v_i)^{(q^k - 1)/p}\right)\\<br />
    &amp;= \left(\prod_i f_{p, u_i}(v_i)\right)^{(q^k - 1)/p}
\end{align}</p>

<h2 id="结论">结论</h2>
<p>本文本来应该只是<a href="#配对的定义">配对的三个性质</a> 的一个简短总结：双线性性、非退化性和高效性。</p>

<p>不幸的是，我觉得很有必要去讨论下其<a href="#历史">迷人的历史</a>。
而且我不能让你在没有看到一些强大的 <a href="#配对的应用">配对的密码学应用</a> 的情况下离开。</p>

<p>之后，我意识到实现基于配对的密码系统的从业者可能会受益于了解其<a href="#how-do-pairings-actually-work">内部工作机制</a>，因为可以利用其中一些细节来加速<a href="#implementation-details">实现</a>。</p>

<h2 id="致谢">致谢</h2>

<p>我要感谢 Dan Boneh 帮助我澄清和了解 Weil 相关的历史，以及 <a href="https://www.youtube.com/watch?v=1RwkqZ6JNeo">他在 2015 年 Simons 的演讲</a>，这启发了我 做更多的研究并写下了这个历史记录。</p>

<p>非常感谢：</p>

<ul>
  <li><a href="https://twitter.com/cronokirby">Lúcás Meier</a>、<a href="https://twitter.com/zkproofs">Pratyush Mishra</a>、<a href="https://twitter.com/rel_zeta_tech">Ariel Gabizon</a> 和 <a href="https://twitter.com/dariofiore0"> Dario Fiore</a>，感谢他们关于“简洁”(S) 在 <strong>S</strong>NARKs<sup id="fnref:GW10:1" role="doc-noteref"><a href="#fn:GW10" class="footnote" rel="footnote">7</a></sup> 中代表什么的启发性观点，并提醒我带有$O(1)$群元素证明大小的 SNARKs 其实存在于 RSA 假设的 <sup id="fnref:LM18:1" role="doc-noteref"><a href="#fn:LM18" class="footnote" rel="footnote">10</a></sup>。</li>
  <li><a href="https://twitter.com/swasilyev">Sergey Vasilyev</a> 指出 BLS12-381 椭圆曲线定义中的拼写错误。</li>
  <li><a href="https://twitter.com/BlakeMScurr">@BlakeMScurr</a> 指出对 Joux 作品的错误引用<sup id="fnref:Joux00:2" role="doc-noteref"><a href="#fn:Joux00" class="footnote" rel="footnote">18</a></sup>。</li>
  <li><a href="https://twitter.com/conradoplg">Conrado Guovea</a> 向我指出了 Victor Miller 关于他如何开发用于求 Weil 配对的算法的说明（<a href="#first-development-millers-algorithm">此处</a> 进行了讨论） 。</li>
  <li><a href="https://twitter.com/ChrisPeikert">Chris Peikert</a> 指出有很多不依赖配对的快速 IBE 方案 <sup id="fnref:DLP14e" role="doc-noteref"><a href="#fn:DLP14e" class="footnote" rel="footnote">29</a></sup>。</li>
</ul>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:GGPR12e" role="doc-endnote">
      <p><strong>Quadratic Span Programs and Succinct NIZKs without PCPs</strong>, by Rosario Gennaro and Craig Gentry and Bryan Parno and Mariana Raykova, <em>in Cryptology ePrint Archive, Paper 2012/215</em>, 2012, <a href="https://eprint.iacr.org/2012/215">[URL]</a> <a href="#fnref:GGPR12e" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:GGPR12e:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:PGHR13e" role="doc-endnote">
      <p><strong>Pinocchio: Nearly Practical Verifiable Computation</strong>, by Bryan Parno and Craig Gentry and Jon Howell and Mariana Raykova, <em>in Cryptology ePrint Archive, Paper 2013/279</em>, 2013, <a href="https://eprint.iacr.org/2013/279">[URL]</a> <a href="#fnref:PGHR13e" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Grot16" role="doc-endnote">
      <p><strong>On the Size of Pairing-Based Non-interactive Arguments</strong>, by Groth, Jens, <em>in Advances in Cryptology – EUROCRYPT 2016</em>, 2016 <a href="#fnref:Grot16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:BLS01" role="doc-endnote">
      <p><strong>Short Signatures from the Weil Pairing</strong>, by Boneh, Dan and Lynn, Ben and Shacham, Hovav, <em>in Advances in Cryptology — ASIACRYPT 2001</em>, 2001 <a href="#fnref:BLS01" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:BLS01:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:BLS01:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:BLS01:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:BF01" role="doc-endnote">
      <p><strong>Identity-Based Encryption from the Weil Pairing</strong>, by Boneh, Dan and Franklin, Matt, <em>in Advances in Cryptology — CRYPTO 2001</em>, 2001 <a href="#fnref:BF01" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:BF01:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:BF01:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:BF01:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:KZG10" role="doc-endnote">
      <p><strong>Constant-Size Commitments to Polynomials and Their Applications</strong>, by Kate, Aniket and Zaverucha, Gregory M. and Goldberg, Ian, <em>in ASIACRYPT’10</em>, 2010 <a href="#fnref:KZG10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:GW10" role="doc-endnote">
      <p><strong>Separating Succinct Non-Interactive Arguments From All Falsifiable Assumptions</strong>, by Craig Gentry and Daniel Wichs, <em>in Cryptology ePrint Archive, Report 2010/610</em>, 2010, <a href="https://eprint.iacr.org/2010/610">[URL]</a> <a href="#fnref:GW10" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:GW10:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:BCCplus16" role="doc-endnote">
      <p><strong>Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting</strong>, by Jonathan Bootle and Andrea Cerulli and Pyrros Chaidos and Jens Groth and Christophe Petit, <em>in Cryptology ePrint Archive, Report 2016/263</em>, 2016, <a href="https://eprint.iacr.org/2016/263">[URL]</a> <a href="#fnref:BCCplus16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Mica98" role="doc-endnote">
      <p><strong>Computationally-Sound Proofs</strong>, by Silvio Micali, <em>in Logic Colloquium ‘95: Proceedings of the Annual European Summer Meeting of the Association of Symbolic Logic</em>, 1998, <a href="https://projecteuclid.org/ebooks/lecture-notes-in-logic/Computationally-Sound-Proofs/chapter/Computationally-Sound-Proofs/lnl/1235415908?tab=ChapterArticleLink">[URL]</a> <a href="#fnref:Mica98" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:LM18" role="doc-endnote">
      <p><strong>Subvector Commitments with Application to Succinct Arguments</strong>, by Russell W.F. Lai and Giulio Malavolta, <em>in Cryptology ePrint Archive, Report 2018/705</em>, 2018, <a href="https://eprint.iacr.org/2018/705">[URL]</a> <a href="#fnref:LM18" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:LM18:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:Wiki22Weil" role="doc-endnote">
      <p><strong>André Weil — Wikipedia, The Free Encyclopedia</strong>, by Wikipedia contributors, 2022, <a href="https://en.wikipedia.org/w/index.php?title=Andr%C3%A9_Weil&amp;oldid=1124211220">[URL]</a> <a href="#fnref:Wiki22Weil" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:danboneh-shimuranote" role="doc-endnote">
      <p>感谢 Dan Boneh，他将 Weil 的定义与 Shimura 在他关于模形式的经典著作中的不同定义进行了对比。 虽然 Shimura 的定义使得证明配对的所有性质变得容易得多，但它将 $n$ 阶配对定义为 $n$个$n^2$阶的点的求和。 这使得它无可救药地不可计算。 另一方面，Weil 的定义涉及对一个非常具体的函数的求值——没有指数大小的求和——但用来证明所有配对的性质需要做更多的工作。 <a href="#fnref:danboneh-shimuranote" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Weil92" role="doc-endnote">
      <p><strong>The Apprenticeship of a Mathematician</strong>, by Weil, Andre, 1992, <a href="https://books.google.ro/books?id=73REHmJ9JNUC">[URL]</a> <a href="#fnref:Weil92" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Mill86Short" role="doc-endnote">
      <p><strong>Short Programs for functions on Curves</strong>, by Victor S. Miller, 1986, <a href="https://crypto.stanford.edu/miller">[URL]</a> <a href="#fnref:Mill86Short" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:miller-talk" role="doc-endnote">
      <p>2010 年 10 月 10 日，Miller在 <a href="https://www.youtube.com/watch?v=yK5fYfn6HJg&amp;t=2901s">微软研究院的演讲</a> 中亲自讲述了这个故事。 <a href="#fnref:miller-talk" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:alin-where" role="doc-endnote">
      <p>除了 Boneh 在 <sup id="fnref:Mill86Short:1" role="doc-noteref"><a href="#fn:Mill86Short" class="footnote" rel="footnote">14</a></sup> 中发表的手稿之外，我找不到任何 Miller 在这方面发表的作品的踪迹。 任何提示我将不胜感激。 <a href="#fnref:alin-where" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:MVO91" role="doc-endnote">
      <p><strong>Reducing Elliptic Curve Logarithms to Logarithms in a Finite Field</strong>, by Menezes, Alfred and Vanstone, Scott and Okamoto, Tatsuaki, <em>in ACM STOC</em>, 1991, <a href="http://doi.acm.org/10.1145/103418.103434">[URL]</a> <a href="#fnref:MVO91" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Joux00" role="doc-endnote">
      <p><strong>A One Round Protocol for Tripartite Diffie–Hellman</strong>, by Joux, Antoine, <em>in Algorithmic Number Theory</em>, 2000 <a href="#fnref:Joux00" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:Joux00:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:Joux00:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:BGN05" role="doc-endnote">
      <p><strong>Evaluating 2-DNF Formulas on Ciphertexts</strong>, by Boneh, Dan and Goh, Eu-Jin and Nissim, Kobbi, <em>in Theory of Cryptography</em>, 2005 <a href="#fnref:BGN05" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:dhe" role="doc-endnote">
      <p>通常，会用一些密钥导出函数 $\mathsf{KDF}$ 用于导出密钥 $k = \mathsf{KDF}(e(g,g)^{abc})$。 <a href="#fnref:dhe" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:TCZplus20" role="doc-endnote">
      <p><strong>Towards Scalable Threshold Cryptosystems</strong>, by Alin Tomescu and Robert Chen and Yiming Zheng and Ittai Abraham and Benny Pinkas and Guy Golan Gueta and Srinivas Devadas, <em>in IEEE S\&amp;P’20</em>, 2020 <a href="#fnref:TCZplus20" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Edgi22" role="doc-endnote">
      <p><strong>BLS12-381 For The Rest Of Us</strong>, by Ben Edgington, 2022, <a href="https://hackmd.io/@benjaminion/bls12-381">[URL]</a> <a href="#fnref:Edgi22" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:BLS02e" role="doc-endnote">
      <p><strong>Constructing Elliptic Curves with Prescribed Embedding Degrees</strong>, by Paulo S.  L.  M.  Barreto and Ben Lynn and Michael Scott, <em>in Cryptology ePrint Archive, Paper 2002/088</em>, 2002, <a href="https://eprint.iacr.org/2002/088">[URL]</a> <a href="#fnref:BLS02e" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Cost12" role="doc-endnote">
      <p><strong>Pairings for beginners</strong>, by Craig Costello, 2012, <a href="https://static1.squarespace.com/static/5fdbb09f31d71c1227082339/t/5ff394720493bd28278889c6/1609798774687/PairingsForBeginners.pdf">[URL]</a> <a href="#fnref:Cost12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:GPS08" role="doc-endnote">
      <p><strong>Pairings for cryptographers</strong>, by Steven D. Galbraith and Kenneth G. Paterson and Nigel P. Smart, <em>in Discrete Applied Mathematics</em>, 2008, <a href="http://www.sciencedirect.com/science/article/pii/S0166218X08000449">[URL]</a> <a href="#fnref:GPS08" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:GPS08:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:Mene05" role="doc-endnote">
      <p><strong>An Introduction to Pairing-Based Cryptography</strong>, by Alfred Menezes, 2005, <a href="https://www.math.uwaterloo.ca/~ajmeneze/publications/pairings.pdf">[URL]</a> <a href="#fnref:Mene05" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:BCMplus15e" role="doc-endnote">
      <p><strong>Subgroup security in pairing-based cryptography</strong>, by Paulo S.  L.  M.  Barreto and Craig Costello and Rafael Misoczki and Michael Naehrig and Geovandro C.  C.  F.  Pereira and Gustavo Zanon, <em>in Cryptology ePrint Archive, Paper 2015/247</em>, 2015, <a href="https://eprint.iacr.org/2015/247">[URL]</a> <a href="#fnref:BCMplus15e" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:BN06Pair" role="doc-endnote">
      <p><strong>Pairing-Friendly Elliptic Curves of Prime Order</strong>, by Barreto, Paulo S. L. M. and Naehrig, Michael, <em>in Selected Areas in Cryptography</em>, 2006 <a href="#fnref:BN06Pair" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:DLP14e" role="doc-endnote">
      <p><strong>Efficient Identity-Based Encryption over NTRU Lattices</strong>, by Léo Ducas and Vadim Lyubashevsky and Thomas Prest, <em>in Cryptology ePrint Archive, Paper 2014/794</em>, 2014, <a href="https://eprint.iacr.org/2014/794">[URL]</a> <a href="#fnref:DLP14e" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Kurt Pan</name></author><category term="双线性映射" /><category term="BLS曲线" /><category term="BLS签名" /><category term="身份基加密" /><summary type="html"><![CDATA[原文：Pairings or bilinear maps 作者：Alin Tomescu 译者：Kurt Pan 摘要： 配对，或者双线性映射，是对密码学来说非常强大的一个数学工具。配对给我们带来了最简洁的零知识证明[^GGPR12e]$^,$[^PGHR13e]$^,$[^Grot16]，最高效的门限签名[^BLS01]，第一个可用的身份基加密（IBE）方案[^BF01] ，以及其它很多高效的密码系统[^KZG10]。本文中，我将介绍一点配对的性质，其密码学应用和令人着迷的历史。事实上，读完此文后，你可能会想要去监狱里待上个一两年。]]></summary></entry></feed>